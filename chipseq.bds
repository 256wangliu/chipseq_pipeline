#!/usr/bin/env bds

helpUnsorted := true // help( $ bds chipseq.bds -h ) will not be sorted

include "modules/align.bds"
include "modules/peakcall.bds"
include "modules/idr.bds"
include "modules/signal.bds"
include "modules/report.bds"
include "modules/conf.bds"


bool kundaje_lab 	= false		help Set it true if you run the pipeline on Kundaje lab servers (automatically set environments, default: false)

string input 		= "fastq"	help Input file type: 5 options (fastq, bam, nodup_bam, tag or peak)

// for fastqs (SE)
string fastq1 		= "" 		help Path for fastq for replicate 1 (single ended).
string fastq2 		= "" 		help Path for fastq for replicate 2 (single ended).
string ctl_fastq1 	= "" 		help Path for control fastq for replicate 1 (single ended).
string ctl_fastq2 	= "" 		help Path for control fastq for replicate 2 (single ended, if not exists leave this blank).

// for fasqts (PE)
string fastq1_1		= "" 		help Path for fastq for replicate 1 pair 1 (paired-end).
string fastq1_2		= "" 		help Path for fastq for replicate 1 pair 2 (paired-end).
string fastq2_1 	= "" 		help Path for fastq for replicate 2 pair 1 (paired-end).
string fastq2_2 	= "" 		help Path for fastq for replicate 2 pair 2 (paired-end).
string ctl_fastq1_1	= "" 		help Path for control fastq for replicate 1 pair 1 (paired-end).
string ctl_fastq1_2	= "" 		help Path for control fastq for replicate 1 pair 2 (paired-end).
string ctl_fastq2_1 	= "" 		help Path for control fastq for replicate 2 pair 1 (paired-end, if not exists leave this blank).
string ctl_fastq2_2 	= "" 		help Path for control fastq for replicate 2 pair 2 (paired-end, if not exists leave this blank).

// for bam data set
string bam1 		= ""		help Path for bam or nodup_bam for replicate 1.
string bam2 		= ""		help Path for bam or nodup_bam for replicate 2.
string ctl_bam1 	= "" 		help Path for control bam or nodup_bam for replicate 1.
string ctl_bam2 	= "" 		help Path for control bam or nodup_bam for replicate 2 (if not exists leave this blank).

bool bam1_PE 		= false 	help Set it true if bam replicate 1 is paired end (default: false).
bool bam2_PE 		= false 	help Set it true if bam replicate 2 is paired end (default: false).
bool ctl_bam1_PE 	= false 	help Set it true if bam control replicate 1 is paired end (default: false).
bool ctl_bam2_PE 	= false 	help Set it true if bam control replicate 2 is paired end (default: false).

// for tag data set
string tag1 		= ""		help Path for tagalign for replicate 1.
string tag2 		= ""		help Path for tagalign for replicate 2.
string ctl_tag1 	= "" 		help Path for control tagalign for replicate 1.
string ctl_tag2 	= "" 		help Path for control tagalign for replicate 2 (if not exists leave this blank).

bool tag1_PE 		= false 	help Set it true if tagalign replicate 1 is paired end (default: false).
bool tag2_PE 		= false 	help Set it true if tagalign replicate 2 is paired end (default: false).
bool ctl_tag1_PE 	= false 	help Set it true if tagalign control replicate 1 is paired end (default: false).
bool ctl_tag2_PE 	= false 	help Set it true if tagalign control replicate 2 is paired end (default: false).

// for peak data set
string peak1 		= ""		help Path for peak 1
string peak2 		= ""		help Path for peak 2
string pooled2 		= ""		help Path for pooled peak

string final_stage	= "" 		help Pipeline will stop after producing final output (bam, nodup_bam, tag, xcor (cross-corr. analysis), peak ). (default: blank).
int num_rep 		= 2		help Number of replicates, define it for non-blank final_stage only. (default: 2).
int num_ctl 		= 1

string html_rpt_title 	= "ChIP-Seq Pipeline HTML Report"
string html_rpt_file 	= "Report.html"	

init_cmd_arg()



// chipseq pipeline starts here
help() // show help if no parameters are given

read_conf() // read configruation file if exists

chk_input_data()

init() // initialization (mkdir out_dir. and set shell environment)

align() // align

write_report()

signal_trk() // signal track generation (tagalign -> wig, bedgraph or bigwig), this goes in parallel with peackcall_idr()

peakcall_idr() // peakcalling (spp, gem or macs2) and idr (no idr after macs2)

write_report()



void read_conf() {

	if ( conf_file_exists() ) {

		// kundaje lab support (automatic shell env. settings)
		kundaje_lab 	= get_conf_val_bool( kundaje_lab,	["KUNDAJE_LAB"] )

		// final stage
		final_stage	= get_conf_val( final_stage, 		["FINAL_STAGE", "FINAL_OUT"] )
		num_rep 	= get_conf_val_int( num_rep, 		["NUM_REP", "NUMREP"] )

		// inputs
		input 		= get_conf_val( input, 			["INPUT_TYPE", "INPUT"] )

		// align	
		mapq_thresh 	= get_conf_val_int( mapq_thresh,	["MAPQ_THRESH"] )
		nreads 		= get_conf_val_int( nreads,		["NREADS"] )

		bwa_idx 	= get_conf_val( bwa_idx, 		["BWA_INDEX_NAME", "BWA_IDX", "BWA_IDX_NAME"] )
		param_bwa_aln 	= get_conf_val( param_bwa_aln, 		["BWA_ALN_PARAM", "PARAM_BWA_ALN"] )

		nth_bwa_aln 	= get_conf_val_int( nth_bwa_aln,	["NTHREADS_BWA_ALN", "NTH_BWA_ALN", "CPU_BWA_ALN"] )
		wt_bwa_aln 	= get_conf_val( wt_bwa_aln, 		["WALLTIME_BWA_ALN", "WT_BWA_ALN", "TIMEOUT_BWA_ALN"] )
		mem_bwa_aln 	= get_conf_val( mem_bwa_aln, 		["MEMORY_BWA_ALN", "MEM_BWA_ALN"] )

		wt_bwa_sam	= get_conf_val( wt_bwa_sam, 		["WALLTIME_BWA_SAM", "WT_BWA_SAM", "TIMEOUT_BWA_SAM"] )
		mem_bwa_sam 	= get_conf_val( mem_bwa_sam, 		["MEMORY_BWA_SAM", "MEM_BWA_SAM"] )

		//signal track genenration
		make_wig	= get_conf_val_bool( make_wig, 		["CREATE_WIG", "MAKE_WIG", "WIG"] )
		make_bedgraph	= get_conf_val_bool( make_bedgraph, 	["CREATE_BEDGRAPH", "MAKE_BEDGRAPH", "BEDGRAPH"] )
		make_bigwig	= get_conf_val_bool( make_bigwig, 	["CONVERT_TO_BIGWIG", "MAKE_BIGWIG", "BIGWIG"] )

		umap		= get_conf_val( umap, 			["UMAP_DIR", "UMAP"] )
		gensz		= get_conf_val( gensz, 			["GENSZ", "GENOMESIZE", "GENOME_SIZE", "GENOME_SZ", "GEN_SZ"] )
		chrsz		= get_conf_val( chrsz, 			["CHROM_SIZES", "CHRSZ", "CHR_SZ"] )

		// peakcalling
		peakcall	= get_conf_val( peakcall, 		["PEAKCALL_METHOD", "PEAKCALL"] )

		npeak 		= get_conf_val_int( npeak,		["NPEAK"] )

		nth_spp 	= get_conf_val_int( nth_spp,		["NTHREADS_SPP", "NTH_SPP", "CPU_SPP"] )
		wt_spp 		= get_conf_val( wt_spp, 		["WALLTIME_SPP", "WT_SPP", "TIMEOUT_SPP"] )
		mem_spp 	= get_conf_val( mem_spp, 		["MEMORY_SPP", "MEM_SPP"] )

		gensz		= get_conf_val( gensz, 			["GENSZ", "GENOMESIZE", "GENOME_SIZE", "GENOME_SZ", "GEN_SZ"] )

		nth_macs2 	= get_conf_val_int( nth_macs2,		["NTHREADS_MACS2", "NTH_MACS2", "CPU_MACS2"] )
		wt_macs2 	= get_conf_val( wt_macs2, 		["WALLTIME_MACS2", "WT_MACS2", "TIMEOUT_MACS2"] )
		mem_macs2 	= get_conf_val( mem_macs2, 		["MEMORY_MACS2", "MEM_MACS2"] )

		seq 		= get_conf_val( seq,			["SEQ_DIR", "SEQ"] )

		nth_gem 	= get_conf_val_int( nth_gem,		["NTHREADS_GEM", "NTH_GEM", "CPU_GEM"] )
		wt_gem 		= get_conf_val( wt_gem, 		["WALLTIME_GEM", "WT_GEM", "TIMEOUT_GEM"] )
		mem_gem 	= get_conf_val( mem_gem, 		["MEMORY_GEM", "MEM_GEM"] )

		// idr
		use_idr1 	= get_conf_val_bool( use_idr1, 		["USE_IDR1"] )
		idr_thresh 	= get_conf_val( idr_thresh, 		["IDR_THRESH"] )

		no_par_job	= get_conf_val_bool( no_par_job, 	["NO_PAR_JOB", "NO_PARALLEL", "NO_PAR"] )

	}

	// if no data for control rep1 and final stage is before peak calling
	// this should be aligment only mode, so ignore all control from here
	if ( is_align_only_mode() ) {
		print("\n\nAlign only mode for $num_rep replicates (no control data found)!\n\n")
		num_ctl = 0
	}
	else {
		num_rep = 2 // # of replicates should be 2 if not align only mode
	}
}

void chk_input_data() {

	print( "\n\n====== Checking inputs (data type = $input) ...\n\n" );

	if ( is_input_peak() ) {

		pooled := get_peak(0)
		peak1 := get_peak(1)
		peak2 := get_peak(2)

		if ( pooled == "" ) error( "Pooled peak input file missing!\n")
		print( "\tPooled peak: $pooled\n")
		if ( !pooled.exists() ) \
			error( "\t\tFile not found!\n")

		if ( peak1 == "" ) error( "Peak 1 input file missing!\n")
		print( "\tPeak1: $peak1\n")
		if ( !peak1.exists() ) \
			error( "\t\tFile not found!\n")

		if ( peak2 == "" ) error( "Peak 2 input file missing!\n")
		print( "\tPeak2: $peak2\n")
		if ( !peak2.exists() ) \
			error( "\t\tFile not found!\n")	

		return
	}

	string[] data_all

	for ( int ctl=0; ctl <= num_ctl; ctl++) { // iterate through replicats (0: not control, 1~: controls)

		for ( int rep=1; rep <= num_rep; rep++) {

			string[] data

			string prefix = (ctl==1) ? "Control " : ""

			if ( is_input_fastq() ) {
				prefix = prefix + "Rep$rep fastq"
				fastqs := get_fastqs( ctl, rep )
				if ( fastqs.size()==0 ) {
					data.push( "" )
				}
				else {
					for ( string fastq : fastqs ) data.push( fastq )
				}
			}
			else if ( is_input_bam() ) {
				prefix = prefix +"Rep$rep bam"
				data.push( get_bam( ctl, rep ) )
			}
			else if ( is_input_nodup_bam() ) {
				prefix = prefix +"Rep$rep nodup_bam"
				data.push( get_bam( ctl, rep ) )
			}
			else if ( is_input_tag() ) {
				prefix = prefix + "Rep$rep tagalign"
				data.push( get_tag( ctl, rep ) )
			}

			print("$prefix :\n")

			for ( string s : data ) {
				print("\t$s\n")
				if ( (s != "") && !(s.exists()) ) error("\t\tFile not found!\n")
			}

			// if data is missing
			if ( data[0] == "" ) {
				if ( (rep==2) && (ctl==1) ) \
					print( "\tWarning: Control $prefix missing! keep going...\n")
				else \
					error( "\t$prefix missing!\n")
			}

			// check any duplicate input filename
			for ( string s : data ) {
				if ( is_in_array( get_basename( s ), get_basename( data_all ) ) ) \
					error( "\t$prefix has duplicate filename!\n")
			}

			data_all = concat( data_all, data )
		}
	}

	if ( final_stage != "" ) \
		print( "\n\n====== Final stage : $final_stage \n\n" );
}

void init() {

	// create output dir.	
	out_dir = mkdir_path( out_dir ) // mkdir and get absolute path

	// set shell environments automatically
	dir_sw_BDS  := "$HOME/software_bds" // location of dependencies installed by the script "install_dependencies.sh"

	if ( kundaje_lab ) {

		print("\n\nAutomatically adding environment variables... (kundaje_lab == true) \n\n")

		SHCMD_INIT = SHCMD_INIT + " . /etc/profile.d/modules.sh; module add bwa/0.7.3 samtools/0.1.19 bedtools/2.19.1 ucsc_tools/3.0.9 picard-tools/1.92;" \
					+ " module add phantompeakqualtools/default idr/latest align2rawsignal/2.0 MACS2/2.1.0 java/latest r/2.15.1 gem/2.6;" \
					+ " export PATH=${PATH}:/software/idrCode; " \
					+ " export _JAVA_OPTIONS='-Xms256M -Xmx512M -XX:ParallelGCThreads=1'; export MAX_JAVA_MEM='8G'; export MALLOC_ARENA_MAX=4"

                SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )

	}
	else if ( dir_sw_BDS.exists() ) { // automatically add software binaries to shell env. vars like PATH

		print("\n\nFound ENCODE ChIP-Seq pipeline software directory ($dir_sw_BDS) \n")
		print("\nAutomatically adding environment variables...\n\n")

		path := " export PATH=" \
			+ "$dir_sw_BDS/bwa-0.7.3:" \
			+ "$dir_sw_BDS/samtools-0.1.19:" \
			+ "$dir_sw_BDS/bedtools2-2.19.1/bin:" \
			+ "$dir_sw_BDS/ucsc_tools:" \
			+ "$dir_sw_BDS/picard-tools-1.92:" \
			+ "$dir_sw_BDS/R-2.15.1/bin:" \
			+ "$dir_sw_BDS/phantompeakqualtools:" \
			+ "$dir_sw_BDS/idr/bin:" \
			+ "$dir_sw_BDS/python3.4/bin:" \
			+ "$dir_sw_BDS/align2rawsignal/bin:" \
			+ "$dir_sw_BDS/idrCode:" \
			+ "$dir_sw_BDS/python2.7/bin:" \
			+ "$dir_sw_BDS/MACS/bin:" \
			+ "$dir_sw_BDS/gem:" \
			+ "\${PATH}"

		shellcmd := "export PICARDROOT=$dir_sw_BDS/picard-tools-1.92; export LAPACK=$dir_sw_BDS/blas/lapack-*/liblapack.a; " \
				+ "export GEMROOT=$dir_sw_BDS/gem; export GEM=$dir_sw_BDS/gem/gem.jar; " \

		shellcmd = shellcmd \
			+ "MCRROOT=$dir_sw_BDS/MATLAB_Compiler_Runtime/v714;" \
			+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRROOT}/runtime/glnxa64;" \
			+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRROOT}/bin/glnxa64;" \
			+ "MCRJRE=\${MCRROOT}/sys/java/jre/glnxa64/jre/lib/amd64;" \
			+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRJRE}/native_threads;" \
			+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRJRE}/server;" \
			+ "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:\${MCRJRE};" \
			+ "XAPPLRESDIR=\${MCRROOT}/X11/app-defaults;" \
			+ "export LD_LIBRARY_PATH;" \
			+ "export XAPPLRESDIR;"

		SHCMD_INIT = SHCMD_INIT + ";" + path + ";" + shellcmd
		SHCMD_INIT = SHCMD_INIT.replace( ";;", ";" )
	}
}

void align() {

	// parallel jobs for align() for each replicate and each control
	for ( int ctl=0; ctl <= num_ctl; ctl++) { // iterate through inputs (ctl==0 : input, ctl==1 : control)	
		
		for ( int rep=1; rep <= num_rep; rep++) {

			if ( !is_data_available( ctl, rep ) ) continue

			string[] data

			// suffix for task name
			info 	:= get_task_info( ctl, rep )

			// prepare data for align()
			if ( is_input_fastq() ) {
				
				data = get_fastqs( ctl, rep )
			}
			else if ( is_input_nodup_bam() ) {

				data = [ get_bam( ctl, rep ) ]
			}
			else if ( is_input_bam() ) {

				data = [ get_bam( ctl, rep ) ]
			}
			else if ( is_input_tag() ) {

				data = [ get_tag( ctl, rep ) ]
			}
			else {
				continue
			}

			if ( data.size() == 0 ) continue

			// align output directory structure
			align_out_dir := mkdir_path( "$out_dir/align_$info" )

			// align() : (ctl==1) is to determine if control or not, if control spr is excluded from align stage
			if ( is_single_ended( ctl, rep ) ) {
				
				if ( no_par_job ) \
					_align( data, input, final_stage, (ctl==1), align_out_dir, info ) // go serial 
				else \
					par _align( data, input, final_stage, (ctl==1), align_out_dir, info ) // go parallel
			}
			else {
				if ( no_par_job ) \
					_align_PE( data, input, final_stage, (ctl==1), align_out_dir, info ) // go serial 
				else \
					par _align_PE( data, input, final_stage, (ctl==1), align_out_dir, info ) // go parallel
			}
		}
	}

	wait
}

void signal_trk() {

	if ( is_input_peak() ) {
		return
	}

	if ( is_final_stage_before_xcor() ) {
		print("Warning: Signal track generation requires cross-corr. analysis (xcor), but final_stage is $final_stage.\n\n")
		return
	}

	for ( int ctl=0; ctl <= num_ctl; ctl++) { // iterate through relicates (0: not control, 1: control)

		for ( int rep=1; rep <= num_rep; rep++) {

			if ( !is_data_available( ctl, rep ) ) continue

			string[] tags

			// suffix for task name
			info 	:= get_task_info( ctl, rep )

			// align output directory
			align_out_dir := mkdir_path( "$out_dir/align_$info" )

			// load tagalign and its self pseudo replicates
			string tag, tag_pr1, tag_pr2
			(tag, tag_pr1, tag_pr2) = load_data( "$align_out_dir/data_tag_$info" )

			// load fraglen
			o := load_data( "$align_out_dir/data_fraglen_$info" )
			fraglen := o[0]

			if ( no_par_job )  \
				_signal_trk( tag, fraglen, out_dir, info )
			else \
				par _signal_trk( tag, fraglen, out_dir, info )
		}
	}

	if ( no_par_job ) wait	
}

void peakcall_idr() {

	if ( is_align_only_mode() ) return

	if ( !is_final_stage_peak() && !is_final_stage_idr() ) return

	 // mkdir and get absolute path

	if ( is_input_peak() ) {
		// idr

		peak_out_dir := mkdir_path( "$out_dir/peaks/" + use_idr1 ? "idr1" : "idr2" )
		
		pooled := get_peak(0)
		peak1  := get_peak(1)
		peak2  := get_peak(2)
		
		//prefix := peak_out_dir + "/"+ make_vs_basename_wo_gz( peak1, peak2, "" )
		//_idr( peak1, peak2, pooled, prefix, "IDR" )
		_idr( peak1, peak2, pooled, peak_out_dir, "IDR" )
		wait

		return
	}

	// peak directory structure 
	peak_out_dir := mkdir_path( "$out_dir/peaks"+"_$peakcall")
	rep_dir := mkdir_path( "$peak_out_dir/true_replicates" )
	pr_dir 	:= mkdir_path( "$peak_out_dir/pseudo_replicates" )
	ppr_dir := mkdir_path( "$peak_out_dir/pooled_pseudoreplicates" )

	// prepare for file names needed for peak calling(index 0:non-control 1:control)

	string tag_rep1, tag_rep1_pr1, tag_rep1_pr2
	string tag_rep2, tag_rep2_pr1, tag_rep2_pr2
	string tag_pooled, tag_ppr1, tag_ppr2

	string ctl_tag_rep1
	string ctl_tag_rep2
	string ctl_tag_pooled

	string info, tmp

	// read rep1 tagalign
	info = get_task_info( 0, 1 )
	(tag_rep1, tag_rep1_pr1, tag_rep1_pr2) = load_data( "$out_dir/align_$info/data_tag_$info" )

	// read rep2 tagalign
	info = get_task_info( 0, 2 )
	(tag_rep2, tag_rep2_pr1, tag_rep2_pr2) = load_data( "$out_dir/align_$info/data_tag_$info" )
 
 	align_pooled_dir := mkdir_path( "$out_dir/align_pooled" )

	// ppr 
	(tag_pooled, tag_ppr1, tag_ppr2 ) = _ppr( tag_rep1, tag_rep1_pr1, tag_rep1_pr2, \
						  tag_rep2, tag_rep2_pr1, tag_rep2_pr2, align_pooled_dir, "" ) // make pooled psudo replicate
	wait

	// read ctl_rep1 tagalign
	info = get_task_info( 1, 1 )
	(ctl_tag_rep1, tmp) = load_data( "$out_dir/align_$info/data_tag_$info" )

	// if ctl_rep2 exists
	if ( is_data_available( 1, 2 ) ) { 

		info = get_task_info( 1, 2 )
		(ctl_tag_rep2, tmp) = load_data( "$out_dir/align_$info/data_tag_$info" )

		ctl_tag_pooled 	= _pool_tag( ctl_tag_rep1, ctl_tag_rep2, out_dir, "ctl" )

		wait
	}
	else {		
		ctl_tag_rep2 	= ctl_tag_rep1

		ctl_tag_pooled 	= ctl_tag_rep1
	}

	// load fraglen info for rep1
	info = get_task_info( 0, 1 )
	o1 := load_data( "$out_dir/align_$info/data_fraglen_" + info )

	fraglen_rep1 := o1[0]

	// load fraglen info for rep2
	info = get_task_info( 0, 2 )
	o2 := load_data( "$out_dir/align_$info/data_fraglen_" + info )

	fraglen_rep2 := o2[0]

	// compute fraglen mean for pooled
	real frgln1 	= fraglen_rep1.parseReal()
	real frgln2 	= fraglen_rep2.parseReal()
	string fraglen_mean 	= round( (frgln1+frgln2)*0.5 )


	// peak calling

	string peak_rep1, peak_rep2, peak_pooled
	string peak_rep1_pr1, peak_rep1_pr2, peak_rep2_pr1, peak_rep2_pr2
	string peak_ppr1, peak_ppr2

	(peak_rep1, tmp)   	= _peakcall( tag_rep1, ctl_tag_rep1, fraglen_rep1, rep_dir, "Rep1" )
	if ( no_par_job ) wait

	(peak_rep2, tmp)   	= _peakcall( tag_rep2, ctl_tag_rep2, fraglen_rep2, rep_dir, "Rep2" )
	if ( no_par_job ) wait

	(peak_pooled, tmp) 	= _peakcall( tag_pooled, ctl_tag_pooled, fraglen_mean, rep_dir, "Pooled" )
	if ( no_par_job ) wait

	(peak_rep1_pr1, tmp) 	= _peakcall( tag_rep1_pr1, ctl_tag_rep1, fraglen_rep1, pr_dir, "Rep1_PR1" )
	if ( no_par_job ) wait

	(peak_rep1_pr2, tmp) 	= _peakcall( tag_rep1_pr2, ctl_tag_rep1, fraglen_rep1, pr_dir, "Rep1_PR2" )
	if ( no_par_job ) wait

	(peak_rep2_pr1, tmp) 	= _peakcall( tag_rep2_pr1, ctl_tag_rep2, fraglen_rep2, pr_dir, "Rep2_PR1" )
	if ( no_par_job ) wait

	(peak_rep2_pr2, tmp) 	= _peakcall( tag_rep2_pr2, ctl_tag_rep2, fraglen_rep2, pr_dir, "Rep2_PR2" )
	if ( no_par_job ) wait

	(peak_ppr1, tmp) 	= _peakcall( tag_ppr1, ctl_tag_pooled, fraglen_mean, ppr_dir, "PPR1" )
	if ( no_par_job ) wait

	(peak_ppr2, tmp) 	= _peakcall( tag_ppr2, ctl_tag_pooled, fraglen_mean, ppr_dir, "PPR2" )
	if ( no_par_job ) wait

	wait

	if ( !is_final_stage_idr() ) return

	// idr

	if ( is_peakcall_spp() || is_peakcall_gem() ) {

		idr_out_dir := mkdir_path( use_idr1 ? "$peak_out_dir/idr1" : "$peak_out_dir/idr2" )

		_idr( peak_rep1, peak_rep2, peak_pooled, idr_out_dir, "Rep1_vs_Rep2" )
		if ( no_par_job ) wait

		_idr( peak_ppr1, peak_ppr2, peak_pooled, idr_out_dir, "PPR1_vs_PPR2" )
		if ( no_par_job ) wait

		_idr( peak_rep1_pr1, peak_rep1_pr2, peak_rep1, idr_out_dir, "Rep1_PR1_vs_Rep1_PR2" )
		if ( no_par_job ) wait

		_idr( peak_rep2_pr1, peak_rep2_pr2, peak_rep2, idr_out_dir, "Rep2_PR1_vs_Rep2_PR2" )
	}

	wait
}


void write_report() {
	_write_report( html_rpt_title, "$out_dir/$html_rpt_file", out_dir )
}

void help() {

	if ( is_cmd_line_arg_empty() ) {

		print(" Usage 1 (command line argument): example starting from two SE fastqs \n")
		print("\n")
		print("\t\$ bds chipseq.bds \\ \n")
		print("\t\t -fastq1 [FASTQ_REP1] \\ \n")
		print("\t\t -fastq2 [FASTQ_REP2] \\ \n")
		print("\t\t -bwa_idx [BWA_INDEX] \\ \n")
		print("\t\t ... \n")
		print("\n")
		print(" Usage 2 (configruation file): \n")
		print("\n")
		print("\t\$ bds chipseq.bds [CONF_FILE] \\ \n")
		print("\n")
		print("\t===[CONF_FILE] contents===\n")
		print("\tFASTQ1= [FASTQ_REP1]\n")
		print("\tFASTQ2= [FASTQ_REP2]\n")
		print("\tBWA_IDX= [BWA_INDEX]\n")
		print("\t\t ...\n")
		print("\n")
		print(" For Sun Grid Engine (SGE) cluster use\n")
		print("\n")
		print("\t\$ bds -s sge chipseq.bds ... \n")
		print("\n")
		print(" For Kundaje lab cluster use (this will automatically set shell environments.)\n")
		print("\n")
		print("\t\$ bds -s sge chipseq.bds ... -kundaje_lab true \n")
		print("\n")
		print("\n")
		print(" List of paramters\n")
		print(" \n")
		print(" === general === \n")
		print(" -out_dir \t\tOutput directory. (default: out)\n")
		print(" -no_par_job \t\tSet if true to serialize all jobs, this option is for desktops with limited memory (default: false)\n")
		print(" \n")
		print(" === inputs ===\n")
		print(" -input \t\tInput file type: 5 options (fastq, bam, nodup_bam, tag or peak)\n")
		print(" \n")
		print(" === for fastqs (SE) === \n")
		print(" -fastq1 \t\tPath for fastq for replicate 1 (single ended).\n")
		print(" -fastq2 \t\tPath for fastq for replicate 2 (single ended).\n")
		print(" -ctl_fastq1 \t\tPath for control fastq for replicate 1 (single ended).\n")
		print(" -ctl_fastq2 \t\tPath for control fastq for replicate 2 (single ended, if not exists leave this blank).\n")
		print(" \n")
		print(" === for fasqts (PE) ===\n")
		print(" -fastq1_1 \t\tPath for fastq for replicate 1 pair 1 (paired-end).\n")
		print(" -fastq1_2 \t\tPath for fastq for replicate 1 pair 2 (paired-end).\n")
		print(" -fastq2_1 \t\tPath for fastq for replicate 2 pair 1 (paired-end).\n")
		print(" -fastq2_2 \t\tPath for fastq for replicate 2 pair 2 (paired-end).\n")
		print(" -ctl_fastq1_1 \t\tPath for control fastq for replicate 1 pair 1 (paired-end).\n")
		print(" -ctl_fastq1_2 \t\tPath for control fastq for replicate 1 pair 2 (paired-end).\n")
		print(" -ctl_fastq2_1 \t\tPath for control fastq for replicate 2 pair 1 (paired-end, if not exists leave this blank).\n")
		print(" -ctl_fastq2_2 \t\tPath for control fastq for replicate 2 pair 2 (paired-end, if not exists leave this blank).\n")
		print(" \n")
		print(" === for bam data set ===\n")
		print(" -bam1 \t\t\tPath for bam for replicate 1.\n")
		print(" -bam2 \t\t\tPath for bam for replicate 2.\n")
		print(" -ctl_bam1 \t\tPath for control bam for replicate 1.\n")
		print(" -ctl_bam2 \t\tPath for control bam for replicate 2 (if not exists leave this blank).\n")
		print(" \n")
		print(" -bam1_PE \t\tSet it true if bam replicate 1 is paired end (default: false).\n")
		print(" -bam2_PE \t\tSet it true if bam replicate 2 is paired end (default: false).\n")
		print(" -ctl_bam1_PE \t\tSet it true if bam control replicate 1 is paired end (default: false).\n")
		print(" -ctl_bam2_PE \t\tSet it true if bam control replicate 2 is paired end (default: false).\n")
		print(" \n")
		print(" === for tag data set ===\n")
		print(" -tag1 \t\t\tPath for tagalign for replicate 1.\n")
		print(" -tag2 \t\t\tPath for tagalign for replicate 2.\n")
		print(" -ctl_tag1 \t\tPath for control tagalign for replicate 1.\n")
		print(" -ctl_tag2 \t\tPath for control tagalign for replicate 2 (if not exists leave this blank).\n")
		print(" \n")
		print(" -tag1_PE \t\tSet it true if tagalign replicate 1 is paired end (default: false).\n")
		print(" -tag2_PE \t\tSet it true if tagalign replicate 2 is paired end (default: false).\n")
		print(" -ctl_tag1_PE \t\tSet it true if tagalign control replicate 1 is paired end (default: false).\n")
		print(" -ctl_tag2_PE \t\tSet it true if tagalign control replicate 2 is paired end (default: false).\n")
		print(" \n")
		print(" === for peak data set ===\n")
		print(" -peak1 \t\tPath for peak 1\n")
		print(" -peak2 \t\tPath for peak 2\n")
		print(" -pooled2 \t\tPath for pooled peak\n")
		print(" \n")
		print(" === alignment only mode (final stage)===\n")
		print(" -final_stage \t\tPipeline will stop after producing final output (bam, nodup_bam, tag, xcor (cross-corr. analysis), peak ). (default: blank).\n")
		print(" -num_rep \t\tNumber of replicates, define it for non-blank final_stage only. (default: 2).\n")
		print(" \n")
		print(" === align\n")
		print(" -bwa_idx \t\tPath for bwa index.\n")
		print(" -rm_chr_from_tag \tIf defined, remove lines including it from all tagaligns. (example: 'other|ribo|mito|_', '_', default: blank).\n")
		print(" \n")
		print(" === peakcall\n")
		print(" -peakcall \t\tChoose peak calling method: spp, macs2 and gem (default: spp).\n")
		print(" -gensz \t\tGenome size; hs for human, mm for mouse (default: hs)\n")
		print(" -chrsz \t\tPath for chrom sizes file for your ref. sequence files (use fetchChromSizes from UCSC tools).\n")
		print(" -seq \t\t\tPath for sequence files (directory where chr*.fa exist).\n")
		print(" \n")
		print(" === idr\n")
		print(" -use_idr1 \t\tIf set true, use IDR1 code. Otherwise use IDR2 code (default: false)\n")
		print(" \n")
		print(" === signal track generation\n")
		print(" -make_wig \t\tSet it true to create wig (default: false).\n")
		print(" -make_bedgraph \tSet it true to create bedgraph (default: false).\n")
		print(" -make_bigwig \t\tSet it true to convert bedgraph to bigwig signal track (default: false).\n")
		print(" \n")
		print(" -umap \t\t\tPath for unique mappability tracks (https:===sites.google.com/site/anshulkundaje/projects/mappability).\n")
		print(" -chrsz \t\tPath for chrom sizes file for your ref. sequence files (use fetchChromSizes from UCSC tools).\n")
		print(" -seq \t\t\tPath for sequence files (directory where chr*.fa exist).\n")
		print(" \n")
		print(" === cluster resource for hard (bottle-necked) jobs\n")
		print(" -nth_bwa_aln \t\tNumber of threads for bwa aln (default: 2).\n")
		print(" -wt_bwa_aln \t\tWalltime for bwa aln (default: 10h).\n")
		print(" -mem_bwa_aln \t\tMax. memory for bwa aln (default: 8G).\n")
		print(" \n")
		print(" -wt_bwa_sam \t\tWalltime for bwa sampe/samse (default: 12h).\n")
		print(" -mem_bwa_sam \t\tMax. memory for bwa sampe/samse (default: 8G).\n")
		print(" \n")
		print(" -nth_spp \t\tNumber of threads for spp (run_spp.R) (default: 2).\n")
		print(" -wt_spp	\tWalltime for spp (default: 10h).\n")
		print(" -mem_spp \t\tMax. memory for spp (default: 8G).\n")
		print(" \n")
		print(" -nth_macs2 \t\tNumber of threads for MACS2 (default: 2)\n")
		print(" -wt_macs2 \t\tWalltime for MACS2 (default: 10h).\n")
		print(" -mem_macs2 \t\tMax. memory for MACS2 (default: 8G).\n")
		print(" \n")
		print(" -nth_gem \t\tNumber of threads for gem (default: 2)\n")
		print(" -wt_gem	\tWalltime for gem (default: 20h).\n")
		print(" -mem_gem \t\tMax. memory for gem (default: 16G).\n")
		print(" \n")
		print(" === cluster resource for all other jobs\n")
		print(" -nth \t\t\tDefault number of threads for all cluster jobs (default: 1).\n")
		print(" -wt \t\t\tDefault walltime for all cluster jobs (example: 8:10:00, 3h, 3600 , default: 6h).\n")
		print(" -mem \t\t\tDefault max. memory for all cluster jobs (example: 4G, 100KB, default: 4G).\n")
		print(" \n")
		print(" === align (advanced options)\n")
		print(" -param_bwa_aln \tParameters for bwa align (default: \"-q 5 -l 32 -k 2\").\n")
		print(" -mapq_thresh \t\tThreshold for removing low MAPQ reads (default: 30).\n")
		print(" -nreads \t\tNumber of reads to be subsampled for cross corr. analysis (default. 15000000).\n")
		print(" \n")
		print(" === idr (advanced options)\n")
		print(" -idr_thresh \t\tIDR threshold (default: 0.02).\n")
		print(" \n")
		print(" === shell environment setting (advanced options)\n")
		print(" -mod \t\t\tEnv. modules separated by ; (example: \"bowtie/2.2.4; bwa/0.7.7; picard-tools/1.92\").\n")
		print(" -shcmd \t\tShell cmds separated by ;. Env. vars should be written as \${VAR} not as \$VAR (example: \"export PATH=\${PATH}:/usr/test; VAR=test\"). \n")
		print(" -addpath \t\tPath to be PREPENDED to env. var. PATH. Allows multiple paths separated by ; (example: \"/bin/test:/bin/test2\")\n")
		print(" \n")

		exit
	}
}







void init_cmd_arg() {
	if ( fastq1 != "" ) fastq1_1 = fastq1
	if ( fastq2 != "" ) fastq2_1 = fastq2
	if ( ctl_fastq1 != "" ) ctl_fastq1_1 = ctl_fastq1
	if ( ctl_fastq2 != "" ) ctl_fastq2_1 = ctl_fastq2
}

string[] get_fastqs( int ctl, int rep ) {  // if paired-end return [PE1, PE2], elseif single-end else return [PE1], else []	
	string[] ret
	for ( int pe=1; pe<=2; pe++ ) {
		str := get_fastq( ctl, rep, pe )
		if ( str.length() > 0 ) { // if not null, append
			ret.add( str )
		}
	}

	return ret
}

string get_fastq( int ctl, int rep, int pe ) {

	key_wo_PE := ( ctl > 0 ? "CTL_FASTQ" : "FASTQ" ) + "_REP" + rep 
	key := key_wo_PE + "_PE" + pe

	key_wo_PE2 := ( ctl > 0 ? "CTL_FASTQ" : "FASTQ" ) + rep 
	key2 := key_wo_PE2 + "_" + pe

	if ( (pe==1) && conf.hasKey( key_wo_PE ) ) {
		return get_path( conf{ key_wo_PE } )
	}
	else if ( (pe==1) && conf.hasKey( key_wo_PE2 ) ) {
		return get_path( conf{ key_wo_PE2 } )
	}
	else if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( (ctl==0) && (rep==1) && (pe==1) ) {
		return fastq1_1
	}
	else if ( (ctl==0) && (rep==1) && (pe==2) ) {
		return fastq1_2
	}
	else if ( (ctl==0) && (rep==2) && (pe==1) ) {
		return fastq2_1
	}
	else if ( (ctl==0) && (rep==2) && (pe==2) ) {
		return fastq2_2
	}
	else if ( (ctl==1) && (rep==1) && (pe==1) ) {
		return ctl_fastq1_1
	}
	else if ( (ctl==1) && (rep==1) && (pe==2) ) {
		return ctl_fastq1_2
	}
	else if ( (ctl==1) && (rep==2) && (pe==1) ) {
		return ctl_fastq2_1
	}
	else if ( (ctl==1) && (rep==2) && (pe==2) ) {
		return ctl_fastq2_2
	}
	else {
		return ""
	}
}

string get_bam( int ctl, int rep ) {

	key := ( ctl > 0 ? "CTL_BAM" : "BAM" ) + "_REP" + rep
	key2 := ( ctl > 0 ? "CTL_BAM" : "BAM" ) + rep

	if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( (ctl==0) && (rep==1) ) {
		return bam1
	}
	else if ( (ctl==0) && (rep==2) ) {
		return bam2
	}
	else if ( (ctl==1) && (rep==1) ) {
		return ctl_bam1
	}
	else if ( (ctl==1) && (rep==2) ) {
		return ctl_bam2
	}
	else {
		return ""
	}
}

string get_tag( int ctl, int rep ) {

	key := ( ctl > 0 ? "CTL_TAG" : "TAG" ) + "_REP" + rep
	key2 := ( ctl > 0 ? "CTL_TAGALIGN" : "TAGALIGN" ) + "_REP" + rep

	key3 := ( ctl > 0 ? "CTL_TAG" : "TAG" ) + rep
	key4 := ( ctl > 0 ? "CTL_TAGALIGN" : "TAGALIGN" ) + rep

	if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( conf.hasKey( key3 ) ) {
		return get_path( conf{ key3 } )
	}
	else if ( conf.hasKey( key4 ) ) {
		return get_path( conf{ key4 } )
	}
	else if ( (ctl==0) && (rep==1) ) {
		return tag1
	}
	else if ( (ctl==0) && (rep==2) ) {
		return tag2
	}
	else if ( (ctl==1) && (rep==1) ) {
		return ctl_tag1
	}
	else if ( (ctl==1) && (rep==2) ) {
		return ctl_tag2
	}
	else {
		return ""
	}
}

string get_peak( int rep ) { // rep0 = pooled peak

	key := ( rep == 0 ? "PEAK_POOLED" : ("PEAK_REP" + rep) )
	key2 := ( rep == 0 ? "PEAK_POOLED" : ("PEAK" + rep) )

	if ( conf.hasKey( key ) ) {
		return get_path( conf{ key } )
	}
	else if ( conf.hasKey( key2 ) ) {
		return get_path( conf{ key2 } )
	}
	else if ( rep==1 ) {
		return peak1
	}
	else if ( rep==2 ) {
		return peak2
	}
	else if ( rep==0 ) {
		return pooled
	}
	else {
		return ""
	}
}

bool is_align_only_mode() {
	return !is_input_peak() && !is_data_available( 1, 1 )
}

bool is_rep2_exist( int ctl ) {
	if ( is_input_fastq() ) {
		fastqs := get_fastqs( ctl, 2 )
		return fastqs.size()>0
	}
	else if ( is_input_bam() || is_input_nodup_bam() ) {
		bam := get_bam( ctl, 2 )
		return bam!=""
	}
	else if ( is_input_tag() ) {
		tag := get_tag( ctl, 2 )
		return tag!=""
	}
	return false;
}

bool is_bam_paired_end( int ctl, int rep ) {
	key := ( ctl > 0 ? "CTL_BAM" : "BAM" ) + rep + "_PE"

	if ( conf.hasKey( key ) ) {
		return conf{ key }.parseBool()
	}
	else if ( (ctl==0) && (rep==1) ) {
		return bam1_PE
	}
	else if ( (ctl==0) && (rep==2) ) {
		return bam2_PE
	}
	else if ( (ctl==1) && (rep==1) ) {
		return ctl_bam1_PE
	}
	else if ( (ctl==1) && (rep==2) ) {
		return ctl_bam2_PE
	}
	else {
		return false
	}
}

bool is_bam_single_ended( int ctl, int rep ) {
	return !is_bam_paired_end( ctl, rep )
}

bool is_bam_PE( int ctl, int rep ) {
	return is_bam_paired_end( ctl, rep )
}

bool is_bam_SE( int ctl, int rep ) {
	return is_bam_single_ended( ctl, rep )
}

bool is_tag_paired_end( int ctl, int rep ) {
	key := ( ctl > 0 ? "CTL_TAG" : "TAG" ) + rep + "_PE"

	if ( conf.hasKey( key ) ) {
		return conf{ key }.parseBool()
	}
	else if ( (ctl==0) && (rep==1) ) {
		return tag1_PE
	}
	else if ( (ctl==0) && (rep==2) ) {
		return tag2_PE
	}
	else if ( (ctl==1) && (rep==1) ) {
		return ctl_tag1_PE
	}
	else if ( (ctl==1) && (rep==2) ) {
		return ctl_tag2_PE
	}
	else {
		return false
	}
}

bool is_tag_single_ended( int ctl, int rep ) {
	return !is_tag_paired_end( ctl, rep )
}

bool is_tag_PE( int ctl, int rep ) {
	return is_tag_paired_end( ctl, rep )
}

bool is_tag_SE( int ctl, int rep ) {
	return is_tag_single_ended( ctl, rep )
}

bool is_paired_end( int ctl, int rep ) {

	if ( is_input_fastq() ) {
		fastqs := get_fastqs( ctl, rep )
		return fastqs.size()==2
	}
	else if ( is_input_bam() || is_input_nodup_bam() ) {		
		return is_bam_PE( ctl, rep )
	}
	else if ( is_input_tag() ) {
		return is_tag_PE( ctl, rep )
	}
	return false;
}

bool is_single_ended( int ctl, int rep ) {

	if ( is_input_fastq() ) {
		fastqs := get_fastqs( ctl, rep )
		return fastqs.size()==1
	}
	else if ( is_input_bam() || is_input_nodup_bam()  ) {
		return is_bam_SE( ctl, rep )
	}
	else if ( is_input_tag() ) {
		return is_tag_SE( ctl, rep )
	}
	return false;
}

bool is_SE( int ctl, int rep ) {
	return is_single_ended( ctl, rep )
}

bool is_PE( int ctl, int rep ) {
	return is_paired_end( ctl, rep )
}

bool is_input_fastq() {
	return input.toLower() == "fastq"
}

bool is_input_bam() {
	return input.toLower() == "bam"
}

bool is_input_nodup_bam() {
	return input.toLower() == "nodup_bam"
}

bool is_input_tag() {
	return input.toLower() == "tag" || input.toLower() == "tagalign"
}

bool is_input_peak() {
	return input.toLower() == "peak"
}

bool is_final_stage_bam() {
	return final_stage.toLower() == "bam"
}

bool is_final_stage_nodup_bam() {
	return final_stage.toLower() == "nodup_bam"
}

bool is_final_stage_tag() {
	return final_stage.toLower() == "tag" || final_stage.toLower() == "tagalign"
}

bool is_final_stage_xcor() {
	return final_stage.toLower() == "xcor"
}

bool is_final_stage_peak() {
	return final_stage.toLower() == "peak"
}

bool is_final_stage_idr() {
	return (final_stage.toLower() == "idr") || (final_stage.toLower() == "")
}

bool is_final_stage_before_nodup_bam() {
	return is_final_stage_bam()
}

bool is_final_stage_before_tag() {
	return is_final_stage_bam() || is_final_stage_nodup_bam()
}

bool is_final_stage_before_xcor() {
	return is_final_stage_bam() || is_final_stage_nodup_bam() || is_final_stage_tag()
}

bool is_final_stage_before_peak() {
	return is_final_stage_bam() || is_final_stage_nodup_bam() || is_final_stage_tag() \
		|| is_final_stage_xcor()
}

bool is_final_stage_before_idr() {
	return is_final_stage_bam() || is_final_stage_nodup_bam() || is_final_stage_tag() \
		|| is_final_stage_xcor() || is_final_stage_peak()
}

string get_task_info( int ctl, int rep ) {
	return ( (ctl>0) ? "ctl_" : "") + "rep" + rep
}

bool is_data_available( int ctl, int rep ) {

	if ( (ctl==1) && (rep>2) ) return false

	if ( is_input_fastq() ) {
		return get_fastqs( ctl, rep ).size() > 0
	}
	else if ( is_input_bam() || is_input_nodup_bam() ) {
		return get_bam( ctl, rep ) != ""
	}
	else if ( is_input_tag() ) {
		return get_tag( ctl, rep ) != ""
	}
	else {
		return false
	}
}
