#!/usr/bin/env bds
#vim: syntax=java


help == chipseq pipeline settings

type 		:= "TF" 	help Type of ChIP-Seq pipeline. TF or histone (default: TF).
histone 	:= false	help Histone ChIP-Seq. Equivalent to '-type histone'
final_stage	:= "" 		help Final stage for pipeline (bam, filt_bam, tag, xcor and peak).
true_rep   	:= false	help Call peaks on true replicates only.
no_pseudo_rep	:= false 	help Do not call peaks on self pseudo replicates.
ctl_depth_ratio := 1.2 		help Cut-off ratio of two control tagaligns for pooling (default: 1.2).
idr_thresh 	:= "0.05"	help IDR threshold : -log_10(score) (default: 0.05).
subsample_xcor 	:= "15M"	help # reads to be subsampled for cross corr. analysis (default: 15M).
subsample 	:= "0" 		help # reads to subsample exp. replicate. Subsampled tagalign will be used for steps downstream (default: 0; no subsampling).
subsample_ctl 	:= "0" 		help # reads to subsample control if non-zero (recommended: 40M or lower).
bam2bw 		:= false	//DISABLED, help (BETA) Create bigwig from filtered bam (using bamCoverage in deepTools).
tag2bw 		:= false 	help (BETA) Create bigwig from tagalign (using align2rawsignal).
make_wig 	:= false	help (BETA) Create wig (works with '-tag2bw' only).
macs2_for_pooled_rep_only := false 	help Generate MACS2 signal tracks for pooled replicate only.
idr_rank 	:= ""  		help Scoring column in narrow peak files for IDR. If not specified, signal.value for SPP peaks (TF) and p.value for MACS2 peaks (histone) are used.
fraglen 	:= 0 		help Manually specify fragment length (default: 0, 0 means parsing fraglen from cross-corr analysis log file).


help() // print help and exit if no parameters are given

include "modules/pipeline_template.bds"

include "modules/input.bds"

include "modules/align_bwa.bds"
include "modules/postalign_bam.bds"
include "modules/postalign_bed.bds"

include "modules/callpeak_spp.bds"
include "modules/callpeak_macs2.bds"
include "modules/callpeak_naive_overlap.bds"
include "modules/callpeak_idr.bds"
include "modules/callpeak_blacklist_filter.bds"

include "modules/signal.bds"



// Important file names are stored in global variables (usually a string map string{} with a key with replicate id and peakcaller name)
// e.g. filt_bam{"Replicate 1"} = filtered bam for replicate 1, peak_pr1{"spp,2"} = peak file for pseudo replicate 1 of replicate 2 generated from spp

string{} flagstat_qc, dup_qc, flagstat_nodup_qc, pbc_qc, xcor_qc, xcor_plot

string{} filt_bam

string{} tag, tag_pr1, tag_pr2
string tag_ppr1, tag_ppr2

string{} peak, peak_pr1, peak_pr2, peak_pooled, peak_ppr1, peak_ppr2
string{} gpeak, gpeak_pr1, gpeak_pr2, gpeak_pooled, gpeak_ppr1, gpeak_ppr2
string{} bpeak, bpeak_pr1, bpeak_pr2, bpeak_pooled, bpeak_ppr1, bpeak_ppr2
string peak_overlap, gpeak_overlap, bpeak_overlap

string{} idr_tr, idr_pr, idr_tr_png, idr_pr_png
string idr_ppr, idr_opt, idr_consv, idr_ppr_png
string idr_qc

string{} sig_trk 	 	// signal tracks from deepTools or bamCoverage: map with key ("$ctl,$rep")
string{} pval_bigwig, fc_bigwig // signal track from macs2



main()


void main() { // chipseq pipeline starts here

	init_chipseq() // read command line parameters or configruation file

	chk_param() // check if parameters are valid

	chk_input( true_rep, no_pseudo_rep ) // if inputs are fastq, bam, or tagalign, check if they exist
	
	align() // align and postalign

	pool_tags() // make pooled tagaligns and choose appropriate control for each replicate

	call_peaks() // call peaks in parallel (MACS2,SPP)

	read_input_peak() // if inputs are peaks, read them

	naive_overlap() // get naive overlap peaks

	do_idr() // IDR

	create_sig_trk() // (BETA)

	// blacklist-filter peaks
	filter_peak() 

	report()
}

void init_chipseq() {

	read_conf_chipseq()

	init_filetable()
}

void read_conf_chipseq() {

	type		= get_conf_val( type,			["type"] )
	histone 	= get_conf_val_bool( histone, 		["histone"] )
	final_stage	= get_conf_val( final_stage, 		["final_stage"] )
	true_rep 	= get_conf_val_bool( true_rep, 		["true_rep"] )
	no_pseudo_rep	= get_conf_val_bool( no_pseudo_rep, 	["no_pseudo_rep"] )
	ctl_depth_ratio = get_conf_val_real( ctl_depth_ratio, 	["ctl_depth_ratio"])		
	idr_thresh 	= get_conf_val( idr_thresh, 		["idr_thresh"] )
	subsample_xcor 	= get_conf_val( subsample_xcor,		["subsample_xcor"] )
	subsample 	= get_conf_val( subsample,		["subsample"] )
	subsample_ctl 	= get_conf_val( subsample_ctl,		["subsample_ctl"] )
	//bam2bw 		= get_conf_val_bool( bam2bw, 		["bam2bw"])
	tag2bw 		= get_conf_val_bool( tag2bw, 		["tag2bw"])
	make_wig	= get_conf_val_bool( make_wig, 		["make_wig"])
	macs2_for_pooled_rep_only = get_conf_val_bool( macs2_for_pooled_rep_only, 	["macs2_for_pooled_rep_only"] )
	idr_rank 	= get_conf_val( idr_rank, 		["idr_rank"] )
	fraglen 	= get_conf_val_int( fraglen, 		["fraglen"] )

	if ( histone ) type = "histone"
	if ( idr_rank == "" ) idr_rank = is_TF_chipseq() ? "signal.value" : "p.value"

	print( "\n\n== chipseq pipeline settings\n")
	print( "Type of ChIP-Seq pipeline\t\t: $type\n")
	print( "Final stage for ChIP-Seq\t\t: $final_stage\n" )
	print( "# replicates \t\t\t\t: "+get_num_rep()+"\n" )
	print( "Peak calling for true reps only\t\t: $true_rep\n" )
	print( "No peak calling for self pseudo reps\t: $no_pseudo_rep\n" )
	print( "Control rep. depth ratio\t\t: $ctl_depth_ratio\n" )
	print( "IDR threshold\t\t\t\t: $idr_thresh\n" )
	print( "# reads to subsample for cross-corr. analysis\t\t: "+parse_number( subsample_xcor)+"\n")
	print( "# reads to subsample exp. replicates (0: no subsampling): "+parse_number( subsample )+"\n")
	print( "# reads to subsample controls (0: no subsampling)\t: "+parse_number( subsample_ctl)+"\n")
	//print( "Create bigwig from filt_bam\t\t: $bam2bw\n")
	print( "Create bigwig from tagalign\t\t: $tag2bw\n")
	print( "Create wig\t\t\t\t: $make_wig\n" )
	print( "Signal tracks for pooled rep. only\t: $macs2_for_pooled_rep_only\n")
	print( "Scoring column for IDR\t\t\t: $idr_rank\n")
	print( "Specified fraglen (0:auto)\t\t: $fraglen\n")
}

void init_filetable() { // init file table labels in HTML report

	// add label to graphviz
	// : Items in filetable will be sorted in the ascending order of rank
 	// : Items added later will have higher rank

	// Level 1
	add_label_to_table("Alignment")
	add_label_to_table("Signal tracks")
	add_label_to_table("Peaks")
	add_label_to_table("QC and logs")

	// Level 2
	for (int i=1; i<=100; i++) \
		add_label_to_table("Replicate $i")
	for (int i=1; i<=100; i++) \
		add_label_to_table("Control $i")
	
	add_label_to_table("True replicates")
	add_label_to_table("Pooled replicate")
	add_label_to_table("Pooled control")
	add_label_to_table("Pseudo-replicates")
	add_label_to_table("Pooled pseudo-replicate")
	add_label_to_table("Pooled pseudo-replicates")
	add_label_to_table("Optimal set")
	add_label_to_table("Conservative set")
	add_label_to_table("Naive overlap")
	add_label_to_table("SPP")
	add_label_to_table("MACS2")
	add_label_to_table("IDR")

	// Level 2 or 3
	add_label_to_table("Pseudo-replicate 1")
	add_label_to_table("Pseudo-replicate 2")
	add_label_to_table("Pooled pseudo-replicate 1")
	add_label_to_table("Pooled pseudo-replicate 2")
	for (int i=1; i<=20; i++) \
	    for (int j=i+1; j<=20; j++) \
	        add_label_to_table("Rep. $i vs Rep. $j")

	// Higher levels
	add_label_to_table("IDR QC")
	add_label_to_table("Fastq")
	add_label_to_table("Fastq 1")
	add_label_to_table("Fastq 2")
	add_label_to_table("BWA map. flagstat log")
	add_label_to_table("Bam")
	add_label_to_table("Filtered bam")
	add_label_to_table("Sorted bam")
	add_label_to_table("Dedup. log")
	add_label_to_table("Map. flagstat log")
	add_label_to_table("PBC log")
	add_label_to_table("Bedpe")
	add_label_to_table("Subsampled bedpe")
	add_label_to_table("Tag-align")
	add_label_to_table("Subsampled tag-align")
	add_label_to_table("Cross-corr. log")
	add_label_to_table("Cross-corr. plot")
	add_label_to_table("P-value")
	add_label_to_table("Fold enrichment")
	add_label_to_table("Narrow peak")
	add_label_to_table("Region peak")
	add_label_to_table("Broad peak")
	add_label_to_table("Gapped peak")
	add_label_to_table("IDR peak")
	add_label_to_table("Peak")
	add_label_to_table("Filtered peak")
	add_label_to_table("Filtered gapped peak")
	add_label_to_table("Filtered broad peak")
	add_label_to_table("IDR plot")
	add_label_to_table("Unthresholded IDR peak")

	// add label to graphviz (short name, long name)

	for (int i=1; i<=50; i++) {
		add_label_to_graph("rep$i", "Replicate $i")
		add_label_to_graph("rep$i-pr1", "Pseudo-replicate 1 for rep. $i")
		add_label_to_graph("rep$i-pr2", "Pseudo-replicate 2 for rep. $i")
		add_label_to_graph("rep$i-pr", "Pseudo replicates for rep. $i")
		for (int j=1; j<=20; j++) {
			add_label_to_graph("rep$i-rep$j", "Rep. $i vs. Rep. $j")
		}
	}
	for (int i=1; i<=100; i++) {
		add_label_to_graph("ctl$i", "Control $i")
	}
	add_label_to_graph("pooled_rep", "Pooled replicate")
	add_label_to_graph("pooled_ctl", "Pooled control")
	add_label_to_graph("ppr", "Pooled pseudo-replicates")
	add_label_to_graph("ppr1", "Pooled pseudo-replicate 1")
	add_label_to_graph("ppr2", "Pooled pseudo-replicate 2")
}

void chk_param() {

	print( "\n\n== checking chipseq parameters ...\n" );
	if ( has_input_fastq() ) 	chk_align_bwa()
	if ( tag2bw ) 			chk_signal_aln2rawsig()
	if ( is_final_stage_idr() ) 	chk_idr()
	if ( is_final_stage_idr() || is_final_stage_peak() ) chk_callpeak_macs2()

	// errors
	if ( !is_input_peak() && need_spp() && !ctl_exists() && !is_final_stage_before_peak() ) \
		error("Cannot call peaks (SPP) without controls!\n")

	if ( multimapping > 0 ) \
		error("Multimapping is not available for chipseq pipeline!\n")

	if ( is_input_peak() && true_rep && get_num_rep() == 1 && is_TF_chipseq() ) \
		error("Cannot perform IDR on with only one replicate when '-true_rep' is turned on!")

	if ( is_histone_chipseq() && macs2_for_pooled_rep_only ) \
		macs2_for_pooled_rep_only = false

	if ( has_pe_input_tag() && parse_number( subsample_xcor ) > 0 ) \
		print("Warning: PE tagaligns cannot be subsampled for cross-corr. analysis.\n")

	if ( has_pe_input_tag() && parse_number( subsample ) > 0 ) \
		print("Warning: PE tagaligns cannot be subsampled!\n")

	if ( has_pe_input_tag(1) && parse_number( subsample_ctl ) > 0 ) \
		error("Warning: PE contol tagaligns cannot be subsampled!\n")
}

void align() {

	if ( is_input_peak() ) return

	// distribute # of threads to each replicate/control according to their file sizes
	// different weight for each data type 3 for fastq, 5 for tagaligns, 1 for others

	int{} filesize

	for ( int ctl=0; ctl <= 1; ctl++) { // iterate through inputs (ctl==0 : exp. replicate, ctl==1 : control)
		if ( ctl==1 && !ctl_exists() ) continue

		for ( int rep=1; rep <= get_num_rep( ctl ); rep++) {		
			if ( !input_file_exists( ctl, rep ) ) continue

			// check file size to distribute_nonzero nth to each nth_app
			// determine # threads for each app related to alignment

			group := get_group_name( ctl, rep )

			// get file size in bytes
			if ( is_input_fastq( ctl, rep ) ) {

				fastqs := get_fastqs( ctl, rep )
				filesize{group} = (fastqs[0]).size()*3 // multiply 3 (weight) to allocate more cpus for align
				if ( fastqs.size() > 1) filesize{group} += (fastqs[1]).size()
			}
			else if ( is_input_bam( ctl, rep ) ) 		filesize{group} = (get_bam( ctl, rep )).size()
			else if ( is_input_filt_bam( ctl, rep ) ) 	filesize{group} = (get_filt_bam( ctl, rep )).size()
			else if ( is_input_tag( ctl, rep ) ) 		filesize{group} = (get_tag( ctl, rep )).size()*5
		}
	}

	nth_rep := distribute_nonzero( nth, filesize )

	// align
	
	for ( int ctl=0; ctl <= 1; ctl++) { // iterate through inputs (ctl==0 : exp. replicate, ctl==1 : control)
		if ( ctl==1 && !ctl_exists() ) continue		

		for ( int rep=1; rep <= get_num_rep( ctl ); rep++) {

			if ( !input_file_exists( ctl, rep ) ) continue

			group := get_group_name( ctl, rep )

			if ( no_par ) align( ctl, rep, nth_rep{group} ) // parallel jobs for align() for each replicate and each control
			else	  par align( ctl, rep, nth_rep{group} ) // parallel jobs for align() for each replicate and each control
		}
	}

	wait

	print( "\n== Done align()\n" )
}

void align( int ctl, int rep, int nth_rep ) {

	if ( is_se( ctl, rep ) ) 	align_SE( ctl, rep, nth_rep )
	else 				align_PE( ctl, rep, nth_rep )
}

void align_SE( int ctl, int rep, int nth_rep ) {
		
	// ctl==0: exp. replicate, ctl==1: control

	group 	:= get_group_name( ctl, rep )
	long 	:= get_long_group_name( ctl, rep )

	aln_o_dir := mkdir( "$out_dir/align/$group" ) // create align output directory
	qc_o_dir  := mkdir( "$out_dir/qc/$group" ) // create qc output dir.

	string bam, flagstat_qc_

	if ( is_input_fastq( ctl, rep ) ) {

		fastqs := get_fastqs( ctl, rep )

		// pool if multiple fastqs
		for ( int i=0; i<fastqs.size(); i++) {
			id := i+1
			suffix := fastqs.size()==1 ? "" : ":$id"
			add_file_to_report( fastqs[i], "fastq$suffix", group, "Alignment/$long/Fastq$suffix" )
		}
		string pooled_fastq
		if ( fastqs.size()==1 ) pooled_fastq = fastqs[0]
		else {
			pooled_fastq = pool_fastq( fastqs, aln_o_dir, group )
			wait
		}

		( bam, flagstat_qc_ ) = bwa( pooled_fastq, aln_o_dir, qc_o_dir, group, nth_rep )
		flagstat_qc{group} = flagstat_qc_

		add_file_to_table( flagstat_qc_, "QC and logs/$long/BWA map. flagstat log")

		wait
	}

	string filt_bam_, dup_qc_, pbc_qc_

	if ( is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {
	
		if ( is_input_bam( ctl, rep ) ) bam = get_bam( ctl, rep )

		add_file_to_report( bam, "bam", group, "Alignment/$long/Bam" )

		if ( is_final_stage_bam() ) return

		if ( no_dup_removal ) {
			string tmp
			( filt_bam_, tmp ) \
				= dedup_bam( bam, aln_o_dir, qc_o_dir, group, nth_rep )
		}
		else {
			( filt_bam_, dup_qc_, flagstat_nodup_qc{group}, pbc_qc_ ) \
				= dedup_bam( bam, aln_o_dir, qc_o_dir, group, nth_rep )			
			dup_qc{group} = dup_qc_
			pbc_qc{group} = pbc_qc_
			add_file_to_table( dup_qc_, "QC and logs/$long/Dedup. log")
			add_file_to_table( pbc_qc_, "QC and logs/$long/PBC log")
		}
		wait
	}

	string tag_

	if ( is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_filt_bam( ctl, rep ) ) filt_bam_ = get_filt_bam( ctl, rep )

		add_file_to_report( filt_bam_, "filt. bam", group, "Alignment/$long/Filtered & deduped bam" )

		filt_bam{group} = filt_bam_

		if ( is_final_stage_filt_bam() ) return

		tag_ = bam_to_tag( filt_bam_, aln_o_dir, group )
		wait
	}

	if ( is_input_tag( ctl, rep ) || is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_tag( ctl, rep ) ) tag_ = get_tag( ctl, rep )

		add_file_to_report( tag_, "tag-align", group, "Alignment/$long/Tag-align" )

		if ( ctl == 0 && parse_number( subsample ) > 0 ) {
			tag_ = subsample_tag( tag_, parse_number( subsample ), aln_o_dir, group )
			wait
		}
		else if ( ctl > 0 && parse_number( subsample_ctl ) > 0 ) {
			tag_ = subsample_tag( tag_, parse_number( subsample_ctl ), aln_o_dir, group )
			wait
		}

		tag{group} = tag_

		if ( is_final_stage_tag() ) return

		string xcor_qc_

		if ( ctl == 0 ) { // if replicate

			subsampled_tag := subsample_tag( tag_, parse_number( subsample_xcor ), aln_o_dir, group )

			string subsampled_tag_pr1, subsampled_tag_pr2

			if ( !true_rep ) { // pseudo replicates

				aln_pr1_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr1" )
				aln_pr2_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr2" )

				string tag_pr1_, tag_pr2_
				(tag_pr1_, tag_pr2_ ) = spr( tag_, aln_pr1_o_dir, aln_pr2_o_dir, group ) // make self pseudo replicate

				add_file_to_report( tag_pr1_, "tag-align", "$group-pr1", \
							"Alignment/Pseudo-replicates/$long/Pseudo-replicate 1/Tag-align" )
				add_file_to_report( tag_pr2_, "tag-align", "$group-pr2", \
							"Alignment/Pseudo-replicates/$long/Pseudo-replicate 2/Tag-align" )

				tag_pr1{group} = tag_pr1_
				tag_pr2{group} = tag_pr2_
				wait
			}

			wait

			// xcor for true rep
			string xcor_qc_, xcor_plot_
			( xcor_qc_, xcor_plot_ ) = xcor( subsampled_tag, qc_o_dir, group, nth_rep )

			xcor_qc{group} = xcor_qc_
			xcor_plot{group} = xcor_plot_

			add_file_to_report( xcor_qc_, "xcor log", group, "QC and logs/$long/Cross-corr. log" )
			add_file_to_table( xcor_plot_, "QC and logs/$long/Cross-corr. plot" )
		}

		if ( is_final_stage_xcor() ) return
	}	
}

void align_PE( int ctl, int rep, int nth_rep ) {

	// ctl==0: exp. replicate, ctl==1: control

	group 	:= get_group_name( ctl, rep )
	long 	:= get_long_group_name( ctl, rep )

	aln_o_dir := mkdir( "$out_dir/align/$group" ) // create align output directory
	qc_o_dir  := mkdir( "$out_dir/qc/$group" ) // create qc output dir.

	string bam, flagstat_qc_

	if ( is_input_fastq( ctl, rep ) ) {

		fastqs_pair1 := get_fastq( ctl, rep, 1 )
		fastqs_pair2 := get_fastq( ctl, rep, 2 )

		if ( fastqs_pair1.size() != fastqs_pair2.size() ) {
			error("Number of fastqs to be pooled for pair 1 and pair 2 do not match!\n")
		}
		for ( int i=0; i<fastqs_pair1.size(); i++) {
			id := i+1
			suffix := fastqs_pair1.size()==1 ? "" : ":$id"

			add_file_to_report( fastqs_pair1[i], "fastq$suffix", group, "Alignment/$long/Fastq 1$suffix" )
			add_file_to_report( fastqs_pair2[i], "fastq$suffix", group, "Alignment/$long/Fastq 2$suffix" )
		}

		string pooled_fastq_pair1, pooled_fastq_pair2
		if ( fastqs_pair1.size()==1 ) {
			pooled_fastq_pair1 = fastqs_pair1[0]
			pooled_fastq_pair2 = fastqs_pair2[0]
		}
		else {
			pooled_fastq_pair1 = pool_fastq( fastqs_pair1, aln_o_dir, group )
			pooled_fastq_pair2 = pool_fastq( fastqs_pair2, aln_o_dir, group )
			wait
		}

		( bam, flagstat_qc_ ) = bwa_PE( pooled_fastq_pair1, pooled_fastq_pair2, aln_o_dir, qc_o_dir, group, nth_rep )
		flagstat_qc{group} = flagstat_qc_

		add_file_to_table( flagstat_qc_, "QC and logs/$long/BWA map. flagstat log")

		wait
	}

	string filt_bam_, dup_qc_, pbc_qc_

	if ( is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_bam( ctl, rep ) ) bam = get_bam( ctl, rep )

		add_file_to_report( bam, "bam", group, "Alignment/$long/Bam" )

		if ( is_final_stage_bam() ) return

		if ( no_dup_removal ) {
			string tmp
			( filt_bam_, tmp ) \
				= dedup_bam_PE( bam, aln_o_dir, qc_o_dir, group, nth_rep )			
		}
		else {
			( filt_bam_, dup_qc_, flagstat_nodup_qc{group}, pbc_qc_ ) \
				= dedup_bam_PE( bam, aln_o_dir, qc_o_dir, group, nth_rep )
			dup_qc{group} = dup_qc_
			pbc_qc{group} = pbc_qc_
			add_file_to_table( dup_qc_, "QC and logs/$long/Dedup. log")
			add_file_to_table( pbc_qc_, "QC and logs/$long/PBC log")
		}

		wait
	}

	string tag_, bedpe
	
	if ( is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_filt_bam( ctl, rep ) ) filt_bam_ = get_filt_bam( ctl, rep )

		add_file_to_report( filt_bam_, "filt bam", group, "Alignment/$long/Filtered & deduped bam" )

		filt_bam{group} = filt_bam_

		if ( is_final_stage_filt_bam() ) return

		bedpe = bam_to_bedpe( filt_bam_, aln_o_dir, group )
		wait

		add_file_to_graph( bedpe, "bedpe", group )

		if ( ctl == 0 && parse_number( subsample ) > 0 ) {
			bedpe = subsample_bedpe( bedpe, parse_number( subsample ), aln_o_dir, group )
			wait
		}
		else if ( ctl > 0 && parse_number( subsample_ctl ) > 0 ) {
			bedpe = subsample_bedpe( bedpe, parse_number( subsample_ctl ), aln_o_dir, group )
			wait
		}

		tag_ = bedpe_to_tag( bedpe, aln_o_dir, group )
		wait
	}

	if ( is_input_tag( ctl, rep ) || is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_tag( ctl, rep ) ) tag_ = get_tag( ctl, rep )

		add_file_to_report( tag_, "tag-align", group, "Alignment/$long/Tag-align" )

		tag{group} = tag_

		if ( is_final_stage_tag() ) return

		if ( ctl == 0 ) { // if replicate

			string subsampled_tag

			if ( bedpe == "" ) \
				subsampled_tag = tag_
			else \
				subsampled_tag = subsample_bedpe_to_tag_xcor( bedpe, parse_number( subsample_xcor ), aln_o_dir, group )

			string tag_pr1_, tag_pr2_

			if ( !true_rep ) { // if replicate

				aln_pr1_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr1" )
				aln_pr2_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr2" )

				if ( bedpe == "" ) { // if starting from tag, we don't have bedpe file
					( tag_pr1_, tag_pr2_ ) = spr_tag_PE( tag_, aln_pr1_o_dir, aln_pr2_o_dir, group )
				}
				else {
					( tag_pr1_, tag_pr2_ ) = spr_PE( bedpe, aln_pr1_o_dir, aln_pr2_o_dir, group )
				}

				tag_pr1{group} = tag_pr1_
				tag_pr2{group} = tag_pr2_

				add_file_to_report( tag_pr1_, "tag-align", "$group-pr1", \
							"Alignment/Pseudo-replicates/$long/Pseudo-replicate 1/Tag-align" )
				add_file_to_report( tag_pr2_, "tag-align", "$group-pr2", \
							"Alignment/Pseudo-replicates/$long/Pseudo-replicate 2/Tag-align" )
			}

			wait

			string xcor_qc_, xcor_plot_
			( xcor_qc_, xcor_plot_ ) = xcor( subsampled_tag, qc_o_dir, group, nth_rep )

			xcor_qc{group} = xcor_qc_
			xcor_plot{group} = xcor_plot_

			add_file_to_report( xcor_qc_, "xcor log", group, "QC and logs/$long/Cross-corr. log" )
			add_file_to_table( xcor_plot_, "QC and logs/$long/Cross-corr. plot" )
		}

		if ( is_final_stage_xcor() ) return
	}
}

void pool_tags() {

	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return

	if ( is_input_peak() ) return

	////////////// pool replicates and controls, then create ppr (pooled pseudoreplicates) before peak calling

	// make a temporary array of tagaligns, control tagaligns
	string[] tags, tags_pr1, tags_pr2, tags_ctl

	for ( int rep=1; rep<=get_num_rep(); rep++ ) {

		tags.add( tag{"rep$rep"} )

	 	if ( !true_rep ) {
			tags_pr1.add( tag_pr1{"rep$rep"} )
			tags_pr2.add( tag_pr2{"rep$rep"} )
		}

		if ( input_file_exists( 1, rep ) ) { // if control exists
			tags_ctl.add( tag{"ctl$rep"} )
		}
	}

	// if multiple tagalign for replicates, pool them
	if ( tags.size() > 1 ) {

	 	aln_pooled_o_dir := mkdir( "$out_dir/align/pooled_rep" )

		tag_pooled := pool_tag( tags, aln_pooled_o_dir, "pooled_rep" )

		add_file_to_report( tag_pooled, "tag-align", "pooled_rep", "Alignment/Pooled replicate/Tag-align" )

		tag{"pooled_rep"} = tag_pooled

	 	if ( !true_rep ) {

		 	aln_ppr1_o_dir   := mkdir( "$out_dir/align/pooled_pseudo_reps/ppr1" )
		 	aln_ppr2_o_dir   := mkdir( "$out_dir/align/pooled_pseudo_reps/ppr2" )

			qc_ppr1_o_dir    := mkdir( "$out_dir/qc/pooled_pseudo_reps/ppr1" ) // create qc output dir.
			qc_ppr2_o_dir    := mkdir( "$out_dir/qc/pooled_pseudo_reps/ppr2" ) // create qc output dir.

			tag_ppr1_ := pool_tag( tags_pr1, aln_ppr1_o_dir, "ppr1" )
			tag_ppr2_ := pool_tag( tags_pr2, aln_ppr2_o_dir, "ppr2" )
			tag_ppr1 = tag_ppr1_ // for thread safety
			tag_ppr2 = tag_ppr2_

			add_file_to_report( tag_ppr1_, "tag-align", "ppr1", \
						"Alignment/Pooled pseudo-replicates/Pooled pseudo-replicate 1/Tag-align" )
			add_file_to_report( tag_ppr2_, "tag-align", "ppr2", \
						"Alignment/Pooled pseudo-replicates/Pooled pseudo-replicate 2/Tag-align" )

			wait
		}
	}

	// if multiple tagalign for controls, pool them
	if ( tags_ctl.size() > 1 ) {

		aln_pooled_ctl_o_dir := mkdir( "$out_dir/align/pooled_ctl" )

		tag_pooled := pool_tag( tags_ctl, aln_pooled_ctl_o_dir, "pooled_ctl" )
		tag{"pooled_ctl"} = tag_pooled

		add_file_to_report( tag_pooled, "tag-align\\n(pooled ctl.)", "pooled_ctl", "Alignment/Pooled control/Tag-align" )
	}

	wait

	print( "\n== Done pool_tags()\n" )
}

void call_peaks() {

	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return

	if ( is_input_peak() ) return

	// make a temporary array of tagaligns, control tagaligns
	string[] tags, tags_pr1, tags_pr2, tags_ctl

	for ( int rep=1; rep<=get_num_rep(); rep++ ) {

		tags.add( tag{"rep$rep"} )

	 	if ( !true_rep ) {
			tags_pr1.add( tag_pr1{"rep$rep"} )
			tags_pr2.add( tag_pr2{"rep$rep"} )
		}

		if ( input_file_exists( 1, rep ) ) { // if control exists
			tags_ctl.add( tag{"ctl$rep"} )
		}
	}

	// choose control (between true and pooled controls) for each replicate
	string{} tag_ctl, tag_ctl_label // key: replicate id, value: actual control used for each replicate (according to control depth ratio)

	if ( tags_ctl.size() == 0 ) { // if no control at all

		tag_ctl{"pooled"} = ""

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			tag_ctl{rep} = ""
		}
	}
	else if ( tags_ctl.size() == 1 ) { // if only one control, use it for all replicates

		tag_ctl{"pooled"} = tags_ctl[0]

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			tag_ctl{rep} = tags_ctl[0]
		}
	}
	else { // if multiple controls, check # of lines in replicate/control tagaligns and apply ctl_depth_ratio

		tag_ctl{"pooled"} = tag{"pooled_ctl"}

		real{} nlines 		// # of lines in tagaligns, key: 0,rep for replicate, 1,rep for control
		real[] nlines_ctl 	// # of lines in control tagaligns

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			nlines{"rep$rep"} = get_num_lines( tag{"rep$rep"} )

			//print("DEBUG: # lines rep $rep tag.: " + nlines{"rep$rep"} + ", " + tag{"rep$rep"} + "\n")

			if ( input_file_exists( 1, rep ) ) { // if control exists

				nlines{"ctl$rep"} = get_num_lines( tag{"ctl$rep"} )
				nlines_ctl.add( nlines{"ctl$rep"} )

				//print("DEBUG: # lines ctl $rep tag.: " + nlines{"ctl$rep"} + ", " + tag{"ctl$rep"} + "\n")
			}
		}

		use_pooled_ctl := false

		for ( int i=0; i<nlines_ctl.size(); i++ ) { // check every # lines in every pair of control tagaligns
			for ( int j=i+1; j<nlines_ctl.size(); j++ ) {

				if ( 	nlines_ctl[i] / nlines_ctl[j] > ctl_depth_ratio || \
					nlines_ctl[j] / nlines_ctl[i] > ctl_depth_ratio ) {

					use_pooled_ctl = true

					print("\nNumber of reads in controls differ by a factor of $ctl_depth_ratio. Using pooled controls.\n" )

					break
				}
			}
		}

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			if ( !use_pooled_ctl && input_file_exists( 1, rep ) ) {
			
				if ( nlines{"ctl$rep"} < nlines{"rep$rep"} ) {

					print("\nFewer reads in control $rep than experiment replicate $rep. Using pooled controls for replicate $rep.\n")

					tag_ctl{rep} = tag{"pooled_ctl"}
				}
				else {
					tag_ctl{rep} = tag{"ctl$rep"}
				}
			}
			else {
				tag_ctl{rep} = tag{"pooled_ctl"}
			}
		}
	}

	wait

	// get fragment length (required for SPP and MACS2)
	string fraglen_ppr1, fraglen_ppr2, fraglen_mean
	string{} fraglen_true, fraglen_pr1, fraglen_pr2 // key = replicate id

	real fraglen_sum = 0.0 // temp var.

	for (int rep=1; rep<=get_num_rep(); rep++) {

		if ( fraglen == 0 ) {
			fraglen_true{rep} = get_fraglen( xcor_qc{"rep$rep"} ) // get fragment length of replicate 1			
		}
		else {
			print("DEBUG: fraglen=$fraglen\n")
			fraglen_true{rep} = fraglen
		}

		if ( !true_rep ) {
			fraglen_pr1{rep} = fraglen_true{rep}
			fraglen_pr2{rep} = fraglen_true{rep}
		}

		fraglen_sum += fraglen_true{rep}.parseReal()
	}

	real num_rep_real = get_num_rep()

	fraglen_mean = round( fraglen_sum / num_rep_real ) // compute fraglen mean for pooled

	if ( !true_rep && get_num_rep() > 1 ) {
		fraglen_ppr1 = fraglen_mean
		fraglen_ppr2 = fraglen_mean
	}

	// distribute # of threads for each peak calling
	int nth_pooled, nth_other
	( nth_pooled, nth_other ) = distribute_nonzero( nth, [ get_num_rep(), 1, 1, 1 ] )

	// create directories for peaks (spp, macs2), signal tracks (macs2)
	string spp_o_dir
	if ( is_TF_chipseq() && ctl_exists() ) spp_o_dir = mkdir( "$out_dir/peak/spp")
	macs2_o_dir 	:= mkdir( "$out_dir/peak/macs2") 
	macs2_sig_o_dir	:= mkdir( "$out_dir/signal/macs2") 

	string tmp

	// call peaks on pooled replicates and pooled pseudo replicates
	if ( get_num_rep() > 1 ) {

		// spp
		if ( is_TF_chipseq() && ctl_exists() ) {

			spp_pooled_o_dir := mkdir( "$spp_o_dir/pooled_rep" )

			( peak_pooled{"spp"}, tmp ) = \
				spp( tag{"pooled_rep"}, tag_ctl{"pooled"}, fraglen_mean, spp_pooled_o_dir, "pooled_rep", nth_pooled )

			add_file_to_report( peak_pooled{"spp"}, "r. peak", "pooled_rep", "Peaks/SPP/Pooled Replicate/Region peak" )
		}

		// macs2
		macs2_pooled_o_dir     := mkdir( "$macs2_o_dir/pooled_rep" )
		macs2_pooled_sig_o_dir := mkdir( "$macs2_sig_o_dir/pooled_rep" )

		( peak_pooled{"macs2"}, gpeak_pooled{"macs2"}, bpeak_pooled{"macs2"}, fc_bigwig{"pooled"}, pval_bigwig{"pooled"} ) = \
			macs2_chipseq( tag{"pooled_rep"}, tag_ctl{"pooled"}, fraglen_mean, true, macs2_pooled_o_dir, macs2_pooled_sig_o_dir, "pooled_rep" )

		add_file_to_report( gpeak_pooled{"macs2"}, "g. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Gapped peak" )
		add_file_to_report( bpeak_pooled{"macs2"}, "b. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Broad peak" )
		add_file_to_report( peak_pooled{"macs2"}, "n. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Narrow peak" )
		add_file_to_report( fc_bigwig{"pooled"}, "signal fc", "pooled_rep", "Signal tracks/MACS2/Pooled replicate/Fold enrichment" )
		add_file_to_report( pval_bigwig{"pooled"}, "signal p-val", "pooled_rep", "Signal tracks/MACS2/Pooled replicate/P-value" )

		if ( !true_rep ) {

			// spp
			if ( is_TF_chipseq() && ctl_exists() ) {
				spp_ppr1_o_dir 	:= mkdir( "$spp_o_dir/pooled_pseudo_reps/ppr1" )
				spp_ppr2_o_dir 	:= mkdir( "$spp_o_dir/pooled_pseudo_reps/ppr2" )

				( peak_ppr1{"spp"}, tmp ) = \
					spp( tag_ppr1, tag_ctl{"pooled"}, fraglen_ppr1, spp_ppr1_o_dir, "ppr1", nth_other )
				( peak_ppr2{"spp"}, tmp ) = \
					spp( tag_ppr2, tag_ctl{"pooled"}, fraglen_ppr2, spp_ppr2_o_dir, "ppr2", nth_other )

				hrchy_ppr1 := "Peaks/SPP/Pooled pseudo-replicates/Pooled pseudo-replicate 1/Region peak"
				hrchy_ppr2 := "Peaks/SPP/Pooled pseudo-replicates/Pooled pseudo-replicate 2/Region peak"

				add_file_to_report( peak_ppr1{"spp"}, "r. peak", "ppr1", hrchy_ppr1 )
				add_file_to_report( peak_ppr2{"spp"}, "r. peak", "ppr2", hrchy_ppr2 )							
			}

			// macs2
			if ( !macs2_for_pooled_rep_only ) {

				macs2_ppr1_o_dir:= mkdir( "$macs2_o_dir/pooled_pseudo_reps/ppr1" )
				macs2_ppr2_o_dir:= mkdir( "$macs2_o_dir/pooled_pseudo_reps/ppr2" )

				( peak_ppr1{"macs2"}, gpeak_ppr1{"macs2"}, bpeak_ppr1{"macs2"} ) = \
					macs2_chipseq( tag_ppr1, tag_ctl{"pooled"}, fraglen_ppr1, false, macs2_ppr1_o_dir, "", "ppr1" )

				( peak_ppr2{"macs2"}, gpeak_ppr2{"macs2"}, bpeak_ppr2{"macs2"} ) = \
					macs2_chipseq( tag_ppr2, tag_ctl{"pooled"}, fraglen_ppr2, false, macs2_ppr2_o_dir, "", "ppr2" )

				add_file_to_report( gpeak_ppr1{"macs2"}, "g. peak", "ppr1", \
					"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Gapped peak" )
				add_file_to_report( gpeak_ppr2{"macs2"}, "g. peak", "ppr2", \
					"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Gapped peak" )
				add_file_to_report( bpeak_ppr1{"macs2"}, "b. peak", "ppr1", \
					"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Broad peak" )
				add_file_to_report( bpeak_ppr2{"macs2"}, "b. peak", "ppr2", \
					"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Broad peak" )
				add_file_to_report( peak_ppr1{"macs2"}, "n. peak", "ppr1", \
					"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Narrow peak" )
				add_file_to_report( peak_ppr2{"macs2"}, "n. peak", "ppr2", \
					"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Narrow peak" )				
			}
		}
	}

	// call peaks for each replicate and pseudo replicates for it
	for (int rep=1; rep<=get_num_rep(); rep++) {

		// spp
		if ( is_TF_chipseq() && ctl_exists() ) {
			spp_true_o_dir		:= mkdir( "$spp_o_dir/rep$rep" )

			( peak{"spp,$rep"}, tmp ) = \
				spp( tag{"rep$rep"}, tag_ctl{rep}, fraglen_true{rep}, spp_true_o_dir, "rep$rep", nth_other )

			add_file_to_report( peak{"spp,$rep"}, "r. peak", "rep$rep", "Peaks/SPP/Replicate $rep/Region peak" )
		}

		// macs2
		if ( !macs2_for_pooled_rep_only ) {

			macs2_true_o_dir	:= mkdir( "$macs2_o_dir/rep$rep" )
			macs2_true_sig_dir 	:= mkdir( "$macs2_sig_o_dir/rep$rep" )

			( peak{"macs2,$rep"}, gpeak{"macs2,$rep"}, bpeak{"macs2,$rep"}, fc_bigwig{rep}, pval_bigwig{rep} ) = \
				macs2_chipseq( tag{"rep$rep"}, tag_ctl{rep}, fraglen_true{rep}, true, macs2_true_o_dir, macs2_true_sig_dir, "rep$rep" )

			add_file_to_report( gpeak{"macs2,$rep"}, "g. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Gapped peak" )
			add_file_to_report( bpeak{"macs2,$rep"}, "b. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Broad peak" )
			add_file_to_report( peak{"macs2,$rep"}, "n. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Narrow peak" )
			add_file_to_report( fc_bigwig{rep}, "signal fc", "rep$rep", "Signal tracks/MACS2/Replicate $rep/Fold enrichment" )
			add_file_to_report( pval_bigwig{rep}, "signal p-val", "rep$rep", "Signal tracks/MACS2/Replicate $rep/P-value" )
		}


		if ( !true_rep ) {

			if ( !no_pseudo_rep ) {

				if ( is_TF_chipseq() && ctl_exists() ) {

					spp_pr1_o_dir 	:= mkdir( "$spp_o_dir/pseudo_reps/rep$rep/pr1" )
					spp_pr2_o_dir 	:= mkdir( "$spp_o_dir/pseudo_reps/rep$rep/pr2" )

					( peak_pr1{"spp,$rep"}, tmp ) = \
						spp( tag_pr1{"rep$rep"}, tag_ctl{rep}, fraglen_pr1{rep}, spp_pr1_o_dir, \
										"rep$rep-pr1", nth_other )

					( peak_pr2{"spp,$rep"}, tmp ) = \
						spp( tag_pr2{"rep$rep"}, tag_ctl{rep}, fraglen_pr2{rep}, spp_pr2_o_dir, \
										"rep$rep-pr2", nth_other )
					
					add_file_to_report( peak_pr1{"spp,$rep"}, "r. peak", "rep$rep-pr1", \
								"Peaks/SPP/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Region peak" )
					add_file_to_report( peak_pr2{"spp,$rep"}, "r. peak", "rep$rep-pr2", \
								"Peaks/SPP/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Region peak" )
				}

				if ( !macs2_for_pooled_rep_only ) {

					macs2_pr1_o_dir := mkdir( "$macs2_o_dir/pseudo_reps/rep$rep/pr1" )
					macs2_pr2_o_dir := mkdir( "$macs2_o_dir/pseudo_reps/rep$rep/pr2" )

					( peak_pr1{"macs2,$rep"}, gpeak_pr1{"macs2,$rep"}, bpeak_pr1{"macs2,$rep"} ) = \
						macs2_chipseq( tag_pr1{"rep$rep"}, tag_ctl{rep}, fraglen_pr1{rep}, false, macs2_pr1_o_dir, "", "rep$rep-pr1" )

					( peak_pr2{"macs2,$rep"}, gpeak_pr2{"macs2,$rep"}, bpeak_pr2{"macs2,$rep"} ) = \
						macs2_chipseq( tag_pr2{"rep$rep"}, tag_ctl{rep}, fraglen_pr2{rep}, false, macs2_pr2_o_dir, "", "rep$rep-pr2" )

					add_file_to_report( gpeak_pr1{"macs2,$rep"}, "g. peak", "rep$rep-pr1", \
						"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Gapped peak" )
					add_file_to_report( gpeak_pr2{"macs2,$rep"}, "g. peak", "rep$rep-pr2", \
						"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Gapped peak" )
					add_file_to_report( bpeak_pr1{"macs2,$rep"}, "b. peak", "rep$rep-pr1", \
						"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Broad peak" )
					add_file_to_report( bpeak_pr2{"macs2,$rep"}, "b. peak", "rep$rep-pr2", \
						"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Broad peak" )
					add_file_to_report( peak_pr1{"macs2,$rep"}, "n. peak", "rep$rep-pr1", \
						"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Narrow peak" )
					add_file_to_report( peak_pr2{"macs2,$rep"}, "n. peak", "rep$rep-pr2", \
						"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Narrow peak" )
				}
			}
		}
	}

	wait

	print( "\n== Done call_peaks()\n" )
}

void read_input_peak() {

	if ( !is_input_peak() ) return // read peaks here

	for ( int rep=0; rep<=get_num_rep_peak(); rep++) { // rep==0 : pooled
		if ( get_num_rep_peak() == 1 && rep==0 ) continue // if only one replicate, skip reading pooled rep

		for (int pse=0; pse<=2; pse++) { // pse==0 : true rep
			if ( true_rep && pse > 0 ) continue
			if ( no_pseudo_rep && rep != 0 && pse > 0 ) continue

			peak_ := get_peak(rep,pse)

			pc := get_peak_caller()

			if ( rep == 0 ) {
				if ( pse == 0 )		peak_pooled{"$pc"} 	= peak_
				else if ( pse == 1 )	peak_ppr1{"$pc"} 	= peak_
				else if ( pse == 2 )	peak_ppr2{"$pc"} 	= peak_
			}
			else {
				if ( pse == 0 )		peak{"$pc,$rep"} 	= peak_
				else if ( pse == 1 )	peak_pr1{"$pc,$rep"} 	= peak_
				else if ( pse == 2 )	peak_pr2{"$pc,$rep"} 	= peak_
			}
		}
	}
}

void naive_overlap() {

	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return
	if ( !peak_exists() ) return // if no peaks from peak caller exit

	// peak caller
	pc := get_peak_caller() // macs2 for histone chipseq, spp for tf chipseq

	string[] filetypes
	if ( is_TF_chipseq() ) {
		filetypes.add("regionPeak")
	}
	else if ( is_histone_chipseq() ) {
		filetypes.add("narrowPeak")
		if ( !is_input_peak() ) {
			filetypes.add("gappedPeak")
			filetypes.add("broadPeak")
		}
	}

	// naive overlap peak
	overlap_o_dir := mkdir( "$out_dir/peak/$pc/overlap" )

	for (int i=0;i<filetypes.size();i++) { // naive overlap per filetype
		filetype := filetypes[i]

		if ( get_num_rep() == 1 ) {
			if ( !true_rep && !no_pseudo_rep ) {

				if ( filetype == "regionPeak" || filetype == "narrowPeak" ) {
					peak_overlap = naive_overlap_peak( filetype, \
							peak{"$pc,1"}, peak_pr1{"$pc,1"}, peak_pr2{"$pc,1"}, overlap_o_dir, "" )
					add_file_to_report( peak_overlap, "peak\\noverlap", "", \
							"Peaks/"+pc.toUpper()+"/Naive overlap/Peak" )
				}
				else if ( filetype == "gappedPeak" ) {
					gpeak_overlap = naive_overlap_peak( filetype, \
							gpeak{"$pc,1"}, gpeak_pr1{"$pc,1"}, gpeak_pr2{"$pc,1"}, overlap_o_dir, "" )
					add_file_to_report( gpeak_overlap, "g. peak\\noverlap", "", \
							"Peaks/"+pc.toUpper()+"/Naive overlap/Gapped peak" )
				}
				else if ( filetype == "broadPeak" ) {
					bpeak_overlap = naive_overlap_peak( filetype, \
							bpeak{"$pc,1"}, bpeak_pr1{"$pc,1"}, bpeak_pr2{"$pc,1"}, overlap_o_dir, "" )
					add_file_to_report( bpeak_overlap, "b. peak\\noverlap", "", \
							"Peaks/"+pc.toUpper()+"/Naive overlap/Broad peak" )
				}
				else {
					error("wrong peak filetype!")
				}
			}
		}
		else {
			string[] peaks // make array of peaks from true replicates
			for ( int rep=1; rep<=get_num_rep(); rep++ ) {
				if ( filetype == "regionPeak" \
					|| filetype == "narrowPeak" ) 	peaks.add( peak{"$pc,$rep"} )
				else if ( filetype == "gappedPeak" )	peaks.add( gpeak{"$pc,$rep"} )
				else if ( filetype == "broadPeak" ) 	peaks.add( bpeak{"$pc,$rep"} )
				else 					error("wrong peak filetype!")
			}

			string peak_ppr1_, peak_ppr2_, peak_pooled_
			if ( filetype == "regionPeak" || filetype == "narrowPeak" ) {
				peak_ppr1_ = true_rep ? "" : peak_ppr1{"$pc"}
				peak_ppr2_ = true_rep ? "" : peak_ppr2{"$pc"}
				peak_pooled_ = peak_pooled{"$pc"}
				peak_overlap = naive_overlap_peak( filetype, peak_pooled_, peaks, peak_ppr1_, peak_ppr2_, \
								overlap_o_dir, "" )
				add_file_to_report( peak_overlap, "peak\\noverlap", "", \
						"Peaks/"+pc.toUpper()+"/Naive overlap/Peak" )
			}
			else if ( filetype == "gappedPeak" ) {
				peak_ppr1_ = true_rep ? "" : gpeak_ppr1{"$pc"}
				peak_ppr2_ = true_rep ? "" : gpeak_ppr2{"$pc"}
				peak_pooled_ = gpeak_pooled{"$pc"}
				gpeak_overlap = naive_overlap_peak( filetype, peak_pooled_, peaks, peak_ppr1_, peak_ppr2_, \
								overlap_o_dir, "" )
				add_file_to_report( gpeak_overlap, "g. peak\\noverlap", "", \
						"Peaks/"+pc.toUpper()+"/Naive overlap/Gapped peak" )
			}
			else if ( filetype == "broadPeak" ) {
				peak_ppr1_ = true_rep ? "" : bpeak_ppr1{"$pc"}
				peak_ppr2_ = true_rep ? "" : bpeak_ppr2{"$pc"}
				peak_pooled_ = bpeak_pooled{"$pc"}
				bpeak_overlap = naive_overlap_peak( filetype, peak_pooled_, peaks, peak_ppr1_, peak_ppr2_, \
								overlap_o_dir, "" )
				add_file_to_report( gpeak_overlap, "b. peak\\noverlap", "", \
						"Peaks/"+pc.toUpper()+"/Naive overlap/Broad peak" )
			}
			else {
				error("wrong peak filetype!")
			}
		}
	}

	wait

	print( "\n== Done naive_overlap()\n" )
}

void do_idr() {

	if ( !is_final_stage_idr() ) return
	if ( is_histone_chipseq() ) return
	if ( !peak_exists() ) return // if no peaks from peak caller exit

	// peak caller
	pc := get_peak_caller()

	idr_o_dir := mkdir( "$out_dir/peak/idr" )

	// IDR on true replicates (on every pair of peaks from replicates)

	for ( int i=1; i<=get_num_rep(); i++ ) {

		for ( int j=i+1; j<=get_num_rep(); j++ ) {

			idr_true_o_dir 	:= mkdir( "$idr_o_dir/true_reps/rep$i-rep$j" )

			(idr_tr{"$i,$j"}, idr_tr_png{"$i,$j"} ) = \
				idr2( peak{"$pc,$i"}, peak{"$pc,$j"}, peak_pooled{"$pc"}, idr_thresh, idr_rank, idr_true_o_dir, "rep$i-rep$j" )

			add_file_to_report( idr_tr{"$i,$j"}, "IDR peak", "rep$i-rep$j", "Peaks/IDR/True replicates/Rep. $i vs. Rep. $j/IDR peak" )			
			add_file_to_table( idr_tr_png{"$i,$j"}, "QC and logs/IDR/True replicates/Rep. $i vs. Rep. $j/IDR plot" )			
		}

		if ( !true_rep && !no_pseudo_rep ) {

			idr_pr_o_dir := mkdir( "$idr_o_dir/pseudo_reps/rep$i" )

			(idr_pr{i}, idr_pr_png{i}) = \
				idr2( peak_pr1{"$pc,$i"}, peak_pr2{"$pc,$i"}, peak{"$pc,$i"}, idr_thresh, idr_rank, idr_pr_o_dir, "rep$i-pr" )

			add_file_to_report( idr_pr{i}, "IDR peak", "rep$i-pr", "Peaks/IDR/Pseudo-replicates/Replicate $i/IDR peak" )
			add_file_to_table( idr_pr_png{i}, "QC and logs/IDR/Pseudo-replicates/Replicate $i/IDR plot" )
		}
	}

	if ( !true_rep && get_num_rep() > 1 ) {

		idr_ppr_o_dir := mkdir( "$idr_o_dir/pooled_pseudo_reps" )

		(idr_ppr, idr_ppr_png) = \
			idr2( peak_ppr1{"$pc"}, peak_ppr2{"$pc"}, peak_pooled{"$pc"}, idr_thresh, idr_rank, idr_ppr_o_dir, "ppr" )

		add_file_to_report( idr_ppr, "IDR peak", "ppr", "Peaks/IDR/Pooled pseudo-replicates/IDR peak" )
		add_file_to_table( idr_ppr_png, "QC and logs/IDR/Pooled pseudo-replicates/IDR plot" )
	}

	wait

	qc_o_dir := mkdir( "$out_dir/qc" ) // create qc output dir.

	// get final idr qc score, use idr final idr narrow peak files from true, pseudo and pooled pseudo reps
	(idr_qc, idr_opt, idr_consv) = idr_final_qc( idr_tr, idr_pr, idr_ppr, idr_o_dir, qc_o_dir, "" )

	add_file_to_report( idr_qc, "IDR QC log", "", "QC and logs/IDR/IDR QC log" )
	add_file_to_report( idr_opt, "opt. IDR peak", "", "Peaks/IDR/Optimal set/IDR peak" )
	add_file_to_report( idr_consv, "consv. IDR peak", "", "Peaks/IDR/Conservative set/IDR peak" )

	wait

	print( "\n== Done do_idr()\n" )	
}

void create_sig_trk() {

	if ( !bam2bw && !tag2bw ) return

	for ( int rep=1; rep <= get_num_rep(); rep++) {

		if ( no_par ) create_sig_trk( rep )
		else	  par create_sig_trk( rep )
	}

	wait

	print( "\n== Done create_sig_trk()\n" )	
}

void create_sig_trk( int rep ) {

	group := "rep$rep"  // key name for global output variable (map)

	if ( bam2bw && filt_bam.hasKey(group) ) { // signal track generation (deeptools)

		sig_o_dir := mkdir( "$out_dir/signal/bam2bw/$group" )

		sig_trk_ := bam_to_bw( filt_bam{group}, sig_o_dir, group, 1 )
		sig_trk{group} = sig_trk_

		add_file_to_report( sig_trk_, "signal", "rep$rep", "Signal tracks/bam2Coverage/Signal track" )
	}

	if ( tag2bw && tag.hasKey(group) && xcor_qc.hasKey(group) ) {

		sig_o_dir := mkdir( "$out_dir/signal/tag2bw/$group" )

		fraglen := get_fraglen( xcor_qc{group} )
		sig_trk_ := tag_to_bw( tag{group}, fraglen, sig_o_dir, group )
		sig_trk{group} = sig_trk_

		add_file_to_report( sig_trk_, "signal", "rep$rep", "Signal tracks/align2rawsignal/Bigwig" )
		
		if ( make_wig ) {

			wig := tag_to_wig( tag{group}, fraglen, sig_o_dir, group )

			add_file_to_report( wig, "signal", "rep$rep", "Signal tracks/align2rawsignal/Wig" )
		}
	}
}

// black list filter and then convert to bigbed (for true replicates only)
void filter_peak() {

	if ( !path_exists( blacklist ) ) return

	// peaks for true replicates
	pc := get_peak_caller()
	if ( get_num_rep() > 1 && peak_pooled.hasKey(pc) ) {
		filt_peak_pooled := \
			blacklist_filter_peak( "narrowPeak", peak_pooled{pc}, (peak_pooled{pc}).dirName(), "peak_pooled" )
	}

	for (int rep=1; rep<=get_num_rep(); rep++) {
		if ( !peak.hasKey(pc+",$rep") ) continue
		filt_peak := \
			blacklist_filter_peak( "narrowPeak", peak{pc+",$rep"}, (peak{pc+",$rep"}).dirName(), "peak $rep" )
	}

	wait

	print( "\n== Done filter_peak_and_convert_to_bigbed()\n" )	
}

void report() {

	wait

	html := html_pipeline_version( "https://github.com/kundajelab/TF_chipseq_pipeline/commit" ) // pipeline version info
	html += html_filetable() 	// treeview for directory and file structure 
	html += html_chipseq_tracks() 	// epigenome browser tracks
	html += html_graph()		// graphviz workflow diagram
	html += html_chipseq_QC()	// show QC tables and images

	report( html )
	write_summary_json()

	print( "\n== Done report()\n" )		
}

string html_chipseq_QC() {

	string[] flagstat_qcs, dup_qcs, flagstat_nodup_qcs, pbc_qcs, xcor_qcs, xcor_plots
	string[] flagstat_headers, dup_headers, flagstat_nodup_headers, pbc_headers, xcor_headers

	for ( int ctl=0; ctl <= 1; ctl++) { // iterate through inputs (ctl==0 : exp. replicate, ctl==1 : control)	
		if ( ctl==1 && !ctl_exists() ) continue		
	
		for ( int rep=1; rep <= get_num_rep( ctl ); rep++) {

			if ( !input_file_exists( ctl, rep ) ) continue

			group := get_group_name( ctl, rep )

			if ( ctl == 0 ) {
				//html_rep_by_id += html_xcor( group, 	[ group ], [ xcor_qc{group} ], [ xcor_plot{group} ], [ group ] )

				if ( xcor_qc.hasKey( group ) ) {
					xcor_qcs 		+= xcor_qc{group}
					xcor_plots 		+= xcor_plot{group}

					xcor_headers 		+= group
				}
			}

			if ( flagstat_qc.hasKey( group ) ) 	flagstat_qcs 		+= flagstat_qc{group}
			if ( dup_qc.hasKey( group ) ) 		dup_qcs 		+= dup_qc{group}
			if ( flagstat_nodup_qc.hasKey( group ) )flagstat_nodup_qcs 	+= flagstat_nodup_qc{group}
			if ( pbc_qc.hasKey( group ) ) 		pbc_qcs			+= pbc_qc{group}

			if ( flagstat_qc.hasKey( group ) ) 	flagstat_headers 	+= group
			if ( dup_qc.hasKey( group ) ) 		dup_headers 		+= group
			if ( flagstat_nodup_qc.hasKey( group ) )flagstat_nodup_headers 	+= group
			if ( pbc_qc.hasKey( group ) ) 		pbc_headers		+= group

		}
	}	

	html := "<div id='chipseq_qc'>"
	
	html += parse_flagstat_to_html( "all", 	flagstat_headers, flagstat_qcs, flagstat_headers, false )
	html += parse_dup_to_html( "all", 		dup_headers, dup_qcs, dup_headers )
	html += parse_flagstat_to_html( "all, filtered",flagstat_nodup_headers, flagstat_nodup_qcs, flagstat_nodup_headers, true )
	html += parse_pbc_to_html( "all", 		pbc_headers, pbc_qcs, pbc_headers )
	html += parse_xcor_to_html( "all", 		xcor_headers, xcor_qcs, xcor_plots, xcor_headers )

	// if idr qc's exists, add them to html
	if ( idr_qc != "" ) 		html += parse_idr_to_html( "idr", idr_qc )

	for ( int i=1; i<=get_num_rep(); i++ ) {
		
		for ( int j=i+1; j<=get_num_rep(); j++ ) {
			if ( idr_tr_png.hasKey("$i,$j") ) html += html_img( idr_tr_png{"$i,$j"}, 800, "true reps (rep$i-rep$j)" ) + "&nbsp"
		}

		if ( !true_rep ) {
			if ( idr_pr_png.hasKey(i) ) html += html_img( idr_pr_png{i}, 800, "rep$i pseudo-reps" ) + "&nbsp"
		}
	}		

	if ( idr_ppr_png != "" ) 	html += html_img( idr_ppr_png, 800, "pooled pseudo-reps" ) + "&nbsp"

	html += "</div><br>"
	return html
}

string html_chipseq_tracks() {

	string[] trk_files, trk_types, trk_names

	if ( pval_bigwig.hasKey( "pooled" ) ) { trk_types += "bigwig"; trk_names += "$title pval (pooled)"; trk_files += pval_bigwig{"pooled"} }
	if ( fc_bigwig.hasKey( "pooled" ) )   { trk_types += "bigwig"; trk_names += "$title fc (pooled)";   trk_files += fc_bigwig{"pooled"}   }

	if ( peak_overlap != "" ) { trk_types += "hammock"; trk_names += "$title peak overlap"; trk_files += peak_to_hammock( peak_overlap ) }
	if ( gpeak_overlap != "" ) { trk_types += "hammock"; trk_names += "$title gpeak overlap"; trk_files += peak_to_hammock( gpeak_overlap ) }

	if ( idr_opt != "" ) {	trk_types += "hammock"; trk_names += "$title peak idr (opt. set)"; trk_files += peak_to_hammock( _get_idr_peak_trk( idr_opt ) ) }
	if ( idr_consv != "" ) {trk_types += "hammock"; trk_names += "$title peak idr (cons. set)"; trk_files += peak_to_hammock( _get_idr_peak_trk( idr_consv ) ) }

	for (int rep=1; rep<=get_num_rep(); rep++) {

		if ( pval_bigwig.hasKey( "rep$rep" ) ) { trk_types += "bigwig"; trk_names += "$title pval (rep$rep)"; trk_files += pval_bigwig{"rep$rep"} }
		if ( fc_bigwig.hasKey( "rep$rep" ) )   { trk_types += "bigwig"; trk_names += "$title fc (rep$rep)";   trk_files += fc_bigwig{"rep$rep"}   }
		if ( idr_pr.hasKey(rep) ) {trk_types += "hammock"; trk_names += "$title peak idr (rep$rep-pr)"; trk_files += peak_to_hammock( _get_idr_peak_trk( idr_pr{rep} ) ) }
	}

	html := html_epg_browser_viz( trk_files, trk_types, trk_names, species_browser )

	return html
}

void help() {

	if ( is_cmd_line_arg_empty() ) {
		printHelp()
		exit
	}
}

bool is_final_stage_bam() {

	return final_stage.toLower() == "bam"
}

bool is_final_stage_filt_bam() {

	return final_stage.toLower() == "filt_bam"
}

bool is_final_stage_tag() {

	return final_stage.toLower() == "tag" || final_stage.toLower() == "tagalign"
}

bool is_final_stage_xcor() {

	return final_stage.toLower() == "xcor"
}

bool is_final_stage_peak() {

	return final_stage.toLower() == "peak"
}

bool is_final_stage_idr() {

	return (final_stage.toLower() == "idr") || (final_stage.toLower() == "")
}

bool is_final_stage_before_peak() {

	return is_final_stage_bam() || is_final_stage_filt_bam() || is_final_stage_tag() || is_final_stage_xcor()
}

bool is_TF_chipseq() {

	return type.toLower() == "tf"
}

bool is_histone_chipseq() {

	return type.toLower() == "histone"
}

string get_peak_caller() {

	if ( is_TF_chipseq() ) 		 return "spp"
	else if ( is_histone_chipseq() ) return "macs2"	
	else 				 return ""
}

bool peak_exists() {

	pc := get_peak_caller()

	return peak.hasKey("$pc,1")
}

bool need_spp() {

	return !is_histone_chipseq()
}

bool need_macs2() {

	return true
}
