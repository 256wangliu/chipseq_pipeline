#!/bin/bash


# For Kundaje lab members, add the following to command line arguments
-mod 'bwa/0.7.3; samtools/0.1.19; bedtools/2.19.1; ucsc_tools/3.0.9; picard-tools/1.92; phantompeakqualtools/default; align2rawsignal/2.0; MACS2/2.1.0; java/latest; r/2.15.1; gem/2.6' \
-addpath '/software/idrCode' \ 
-shcmd 'export _JAVA_OPTIONS="-Xms256M -Xmx512M -XX:ParallelGCThreads=1"; export MAX_JAVA_MEM="8G"; export MALLOC_ARENA_MAX=4'


## For single eneded data set

# Alignment, SPP and Nathan Boley's IDR (if idr_nboley is false, use Anshul's IDR instead)
bds ~/ENCODE_chipseq_pipeline/tf_chipseq.bds \
-prefix ENCSR000EGM \
-input fastq \
-fastq1 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLW.fastq.gz \
-fastq2 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLY.fastq.gz \
-ctl_fastq1 /DATA/ENCODE/ENCSR000EGM/Ctl/ENCFF000YRB.fastq.gz \
-idx_bwa /DATA/hg19/encodeHg19Male_v0.7.10/encodeHg19Male_bwa-0.7.10.fa \
-idr_nboley true


# Start from tagAligns, SPP and Nathan Boley's IDR (if idr_nboley is false, use Anshul's IDR instead)
# tagalign_PE = false because it's single ended
bds ~/ENCODE_chipseq_pipeline/tf_chipseq.bds \
-prefix ENCSR000EGM \
-input tagalign \
-tagalign_PE false \
-tagalign1 /DATA/ENCODE/ENCSR000EGM/T1.tagAlign.gz \
-tagalign2 /DATA/ENCODE/ENCSR000EGM/T2.tagAlign.gz \
-ctl_tagalign1 /DATA/ENCODE/ENCSR000EGM/Ctl/T3.tagAlign.gz \
-idr_nboley true

# Alignment, histone chipseq (peak calling using macs2)
bds ~/ENCODE_chipseq_pipeline/tf_chipseq.bds \
-prefix ENCSR000EGM \
-input bam \
-bam_PE false \
-bam1 /DATA/ENCODE/ENCSR000EGM/BAM1.bam \
-bam2 /DATA/ENCODE/ENCSR000EGM/BAM2.bam \
-ctl_bam1 /DATA/ENCODE/ENCSR000EGM/Ctl/BAM3.bam \
-peakcall macs2 \
-gensz hs

# histone chipseq (peak calling using macs2)
bds ~/ENCODE_chipseq_pipeline/tf_chipseq.bds \
-prefix ENCSR000EGM \
-input fastq \
-fastq1 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLW.fastq.gz \
-fastq2 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLY.fastq.gz \
-ctl_fastq1 /DATA/ENCODE/ENCSR000EGM/Ctl/ENCFF000YRB.fastq.gz \
-idx_bwa /DATA/hg19/encodeHg19Male_v0.7.10/encodeHg19Male_bwa-0.7.10.fa \
-peakcall macs2 \
-gensz hs



## For paired end data set (each replicate has two fastqs)

# Alignment, SPP and Nathan Boley's IDR (if idr_nboley is false, use Anshul's IDR instead)
bds ~/ENCODE_chipseq_pipeline/tf_chipseq.bds \
-prefix ENCSR000EGM \
-input fastq \
-fastq1_1 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLW.fastq.gz \
-fastq1_1 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLW2.fastq.gz \
-fastq2_2 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLY.fastq.gz \
-fastq2_2 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLY2.fastq.gz \
-ctl_fastq1_1 /DATA/ENCODE/ENCSR000EGM/Ctl/ENCFF000YRB.fastq.gz \
-ctl_fastq1_2 /DATA/ENCODE/ENCSR000EGM/Ctl/ENCFF000YRB2.fastq.gz \
-idx_bwa /DATA/hg19/encodeHg19Male_v0.7.10/encodeHg19Male_bwa-0.7.10.fa \
-idr_nboley true



## Mixed up data (with paired end fastqs but with single ended control fastq)

# Alignment, SPP and Nathan Boley's IDR (if idr_nboley is false, use Anshul's IDR instead)
bds ~/ENCODE_chipseq_pipeline/tf_chipseq.bds \
-prefix ENCSR000EGM \
-input fastq \
-fastq1_1 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLW.fastq.gz \
-fastq1_1 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLW2.fastq.gz \
-fastq2_2 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLY.fastq.gz \
-fastq2_2 /DATA/ENCODE/ENCSR000EGM/ENCFF000YLY2.fastq.gz \
-ctl_fastq1 /DATA/ENCODE/ENCSR000EGM/Ctl/ENCFF000YRB.fastq.gz \
-idx_bwa /DATA/hg19/encodeHg19Male_v0.7.10/encodeHg19Male_bwa-0.7.10.fa \
-idr_nboley true

