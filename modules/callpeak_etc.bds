#!/usr/bin/env bds
#vim: syntax=java

include "species.bds"
include "report.bds"


help == callpeak etc settings
npeak_filt	 	:= 500000 	help # top peaks filtered from a narrow peak files (default: 500000).



string _filt_out_bad_npeaks( string npeakfile, string o_dir, string label ) {

	return _filt_out_bad_npeaks( npeakfile, o_dir, label, \
				"peak_macs2_($label)", "peak_macs2_filt_($label)", "L1_peak/filt/$label/peak_filt" )
}

string _filt_out_bad_npeaks( string npeakfile, string o_dir, string label, \
			string graph_in, string graph_out, string hrchy_out ) {

	prefix 		:= replace_dir( rm_ext( npeakfile, ["narrowPeak"] ), o_dir )
	npeakfile_filt 	:= "$prefix.$npeak_filt.narrowPeak.gz"

	in 	:= [ npeakfile ]
	out 	:= npeakfile_filt
	taskName:= "filt_out_bad_npeaks " + label

	task ( out<-in ) {

		sys $shcmd_init

		// sort by 8th (-log10(pval) ) column and take top $npeak_filt lines
		sys zcat $npeakfile | sort -grk8 | head -n $npeak_filt | gzip -c > $npeakfile_filt
	}

	_add_to_graphviz( [graph_in], [npeakfile], [graph_out], [npeakfile_filt] )

	_add_to_filetable( [hrchy_out], [npeakfile_filt] )

	wait_par()

	return out	
}

string _naive_overlap_peak( string filetype, string peak_pooled, string peak_rep1, string peak_rep2, \
			    string o_dir, string label ) {

	prefix 	:= replace_dir( rm_ext( peak_pooled, ["regionPeak","regionpeak","narrowPeak","narrowpeak","broadPeak","broadpeak","gappedPeak","gappedpeak",filetype] ), o_dir )
	peak_PooledInRep1AndRep2 	:= "$prefix.PooledInRep1AndRep2.$filetype.gz"
	peak_final 			:= "$prefix.naive_overlap.$filetype.gz"

	string awk_param

	if ( filetype.toLower() == "narrowpeak" || filetype.toLower() == "regionpeak" ) {

		awk_param = "{s1=$3-$2; s2=$13-$12; if (($21/s1 >= 0.5) || ($21/s2 >= 0.5)) {print $0}}"
	}
	else if ( filetype.toLower() == "broadpeak") { 

		awk_param = "{s1=$3-$2; s2=$12-$11; if (($19/s1 >= 0.5) || ($19/s2 >= 0.5)) {print $0}}"
	}
	else if ( filetype.toLower() == "gappedpeak") { 

		awk_param = "{s1=$3-$2; s2=$18-$17; if (($31/s1 >= 0.5) || ($31/s2 >= 0.5)) {print $0}}"
	}
	else {
		error("Unsupport peak file type! ($filetype)\n")
	}

	in 	:= [ peak_pooled, peak_rep1, peak_rep2 ]
	out 	:= peak_final
	
	taskName:= "naive_overlap_thresh " + label

	task( out<-in ) {

		sys $shcmd_init

		//# Find pooled peaks that overlap Rep1 and Rep2 where overlap is defined as the fractional overlap wrt any one of the overlapping peak pairs  >= 0.5
		sys intersectBed -wo -a $peak_pooled -b $peak_rep1 | \
			awk 'BEGIN{FS="\t";OFS="\t"} $awk_param' | cut -f 1-10 | sort | uniq | \
			intersectBed -wo -a stdin -b $peak_rep2 | \
			awk 'BEGIN{FS="\t";OFS="\t"} $awk_param' | cut -f 1-10 | sort | uniq | gzip -c > $peak_PooledInRep1AndRep2

		//# Combine peak lists
		sys zcat $peak_PooledInRep1AndRep2 | sort | uniq | gzip -c > $peak_final

		sys rm -f $peak_PooledInRep1AndRep2
	}

	wait_par()

	return peak_final
}

string _naive_overlap_peak( string filetype, string peak_pooled, string peak_rep1, string peak_rep2, \
			    string peak_ppr1, string peak_ppr2, string o_dir, string label ) {

	prefix 	:= replace_dir( rm_ext( peak_pooled, ["regionPeak","regionpeak","narrowPeak","narrowpeak","broadPeak","broadpeak","gappedPeak","gappedpeak",filetype] ), o_dir )
	peak_PooledInRep1AndRep2 	:= "$prefix.PooledInRep1AndRep2.$filetype.gz"
	peak_PooledInPsRep1AndPsRep2 	:= "$prefix.PooledInPsRep1AndPsRep2.$filetype.gz"
	peak_final 			:= "$prefix.naive_overlap.$filetype.gz"

	string awk_param

	if ( filetype.toLower() == "narrowpeak" || filetype.toLower() == "regionpeak" ) {

		awk_param = "{s1=$3-$2; s2=$13-$12; if (($21/s1 >= 0.5) || ($21/s2 >= 0.5)) {print $0}}"
	}
	else if ( filetype.toLower() == "broadpeak") { 

		awk_param = "{s1=$3-$2; s2=$12-$11; if (($19/s1 >= 0.5) || ($19/s2 >= 0.5)) {print $0}}"
	}
	else if ( filetype.toLower() == "gappedpeak") { 

		awk_param = "{s1=$3-$2; s2=$18-$17; if (($31/s1 >= 0.5) || ($31/s2 >= 0.5)) {print $0}}"
	}
	else {
		error("Unsupport peak file type! ($filetype)\n")
	}

	in 	:= [ peak_pooled, peak_rep1, peak_rep2, peak_ppr1, peak_ppr2 ]
	out 	:= peak_final
	
	taskName:= "naive_overlap_thresh " + label

	task( out<-in ) {

		sys $shcmd_init

		//# Find pooled peaks that overlap Rep1 and Rep2 where overlap is defined as the fractional overlap wrt any one of the overlapping peak pairs  >= 0.5
		sys intersectBed -wo -a $peak_pooled -b $peak_rep1 | \
			awk 'BEGIN{FS="\t";OFS="\t"} $awk_param' | cut -f 1-10 | sort | uniq | \
			intersectBed -wo -a stdin -b $peak_rep2 | \
			awk 'BEGIN{FS="\t";OFS="\t"} $awk_param' | cut -f 1-10 | sort | uniq | gzip -c > $peak_PooledInRep1AndRep2

		//# Find pooled peaks that overlap PseudoRep1 and PseudoRep2 where overlap is defined as the fractional overlap wrt any one of the overlapping peak pairs  >= 0.5
		sys intersectBed -wo -a $peak_pooled -b $peak_ppr1 | \
			awk 'BEGIN{FS="\t";OFS="\t"} $awk_param' | cut -f 1-10 | sort | uniq | \
			intersectBed -wo -a stdin -b $peak_ppr2 | \
			awk 'BEGIN{FS="\t";OFS="\t"} $awk_param' | cut -f 1-10 | sort | uniq | gzip -c > $peak_PooledInPsRep1AndPsRep2

		//# Combine peak lists
		sys zcat $peak_PooledInRep1AndRep2 $peak_PooledInPsRep1AndPsRep2 | sort | uniq | gzip -c > $peak_final

		sys rm -f $peak_PooledInRep1AndRep2 $peak_PooledInPsRep1AndPsRep2
	}

	wait_par()

	return peak_final
}

