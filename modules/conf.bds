#!/usr/bin/env bds
#vim: syntax=java

include "base.bds"


help == configuration file settings
c		:= "" 				help Configuration file path.
env		:= "$script_dir/conf/env.conf"	help Environment file path.
dir_sw 		:= "$HOME/software_bds" 	help Root directory for dependencies installed with 'install_dependencies.sh [DIR_SW]'.


string{} conf 	// map for configuration


init_conf()


void init_conf() {

	env_ := "$script_dir/conf/env.conf" 	// default environment file

	if ( is_cmd_line_arg_empty() ) print( "\nWarning: No parameters are given (specify cmd. line arguments or configuration file)!\n\n")
	
	if ( is_first_arg_conf() ) c = args[0]

	add_to_conf( c, "" ) // then read conf. file
	dir_sw 		= get_conf_val( dir_sw, 	["dir_sw"] )
	env		= get_conf_val( env, 		["env"] )

	add_to_conf( env, "" )

	if ( env==env_ && path_exists( dir_sw ) ) {

		add_to_conf( env, "local-install" )
	}
	else {
		add_to_conf( env, hostname )
	}

	add_to_conf( c, "" ) // read conf again to override

	dir_sw 		= get_conf_val( dir_sw, 	["dir_sw"] ) // read again

	print( "\n\n== configuration file settings\n")
	print( "Hostname\t\t\t\t: $hostname\n")
	print( "Configuration file\t\t\t: $c\n" )
	print( "Environment file\t\t\t: $env\n" )
	print( "\nRoot dir. for locally installed dependencies\t: $dir_sw\n" )
}

string{} read_conf( string file, string section ) {

	section = section.trim().toLower()

	string{} ret

	if ( file == "" ) return ret

	lines := file.read().split("\n")

	can_read := (section=="") ? true : false

	//print( "read_conf: $file, $section\n" )

	for ( string line : lines ) {

		line = rm_comment( line.trim() )

		if ( line == "" ) continue
		
		if ( line.startsWith( "[" ) && line.endsWith( "]" ) )  {

			line2 := line.substr(1,line.length()-1)

			string[] hostnames
			string alias

			// find alias if exists
			arr := line2.split(":")

			//print("DEBUG: $line2 :" + arr[0] + "\n")
			if ( arr.size() > 1 ) 	alias = arr[1].trim().toLower()

			hostnames = arr[0].split(",")

			if ( section == "" ) {

				can_read = false
			}
			else { 

				for ( string host : hostnames ) {

					host = host.trim().toLower()

					if ( section == host ) {

						if ( section == alias ) {
							error("Recursion (section name == alias) found in a conf. or an env. file! (file: $file, section: $section, alias: $alias)\n")
						}
						else if ( alias != "" ) {
							print("\tReading parameters from section ($section) or alias($alias) in file($file)...\n")

							return read_conf( file, alias )
						}
						else {
							print("\tReading parameters from section ($section) or alias($alias) in file($file)...\n")

							can_read = true
						}
					}
					else {
						can_read = false
					}
				}
			}

			continue
		}

		if ( can_read ) {
			string key, val
			(key, val) = parse_conf_line( line )

			//print( "\t$key : $val \n" )
			ret{ key } = val
		}
	}
	return ret
}

string{} read_conf( string file ) {

	return read_conf( file, "" )
}

void add_to_conf( string file, string section ) {

	tmp := read_conf( file, section )

	for( string k : tmp.keys() ) conf{k} = tmp{k}
}

void add_to_conf( string file ) {

	tmp := read_conf( file )

	for( string k : tmp.keys() ) {
		conf{k} = tmp{k}
	}	
}

string[] parse_conf_line( string line ) {

	delims := [ "=", "\t", ":" ]

	delim_found := false

	string key, val

	for ( string delim : delims ) {
		idx := line.indexOf( delim )
		if ( idx > -1 ) {
			key = line.substr( 0, idx ).trim().toLower()
			val = line.substr( idx+1 ).trim()
			delim_found = true
			break
		}
	}

	if ( !delim_found ) error("No delimiter (=,\\t,:) found in line ($line) in the configruation file.\n")

	return [key, val]
}

int get_conf_val_int( int curr_val, string key ) {

	string{} tmp
	return parse_int( get_conf_val( curr_val, key, tmp ) )
}

int get_conf_val_int( int curr_val, string[] keys ) {

	string{} tmp
	return parse_int( get_conf_val( curr_val, keys, tmp ) )
}

bool get_conf_val_bool( bool curr_val, string key ) {

	string{} tmp
	return parse_bool( get_conf_val( curr_val, key, tmp ) )
}

bool get_conf_val_bool( bool curr_val, string[] keys ) {

	string{} tmp
	return parse_bool( get_conf_val( curr_val, keys, tmp ) )
}

real get_conf_val_real( real curr_val, string key ) {

	string{} tmp
	return parse_real( get_conf_val( curr_val, key, tmp ) )
}

real get_conf_val_real( real curr_val, string[] keys ) {

	string{} tmp
	return parse_real( get_conf_val( curr_val, keys, tmp ) )
}

int get_conf_val_int( int curr_val, string key, string{} _conf ) {

	return parse_int( get_conf_val( curr_val, key, _conf ) )	
}

int get_conf_val_int( int curr_val, string[] keys, string{} _conf ) {

	return parse_int( get_conf_val( curr_val, keys, _conf ) )	
}

bool get_conf_val_bool( bool curr_val, string key, string{} _conf ) {

	return parse_bool( get_conf_val( curr_val, key, _conf ) )	
}

bool get_conf_val_bool( bool curr_val, string[] keys, string{} _conf ) {

	return parse_bool( get_conf_val( curr_val, keys, _conf ) )	
}

real get_conf_val_real( real curr_val, string key, string{} _conf ) {

	return parse_real( get_conf_val( curr_val, key, _conf ) )
}

real get_conf_val_real( real curr_val, string[] keys, string{} _conf ) {

	return parse_real( get_conf_val( curr_val, keys, _conf ) )
}

string get_conf_val( string curr_val, string key, string{} _conf ) {	

	key = key.toLower().trim()

	if ( cmd_line_arg_has_key( key ) ) return curr_val

	if ( _conf.size() == 0 ) {
		if ( conf.hasKey( key ) ) {
			
			return (conf{ key } != "") ? substitute_var( rm_comment( conf{ key } ) ) : curr_val
		}
	}
	else {
		if ( _conf.hasKey( key ) ) {
			
			return (_conf{ key } != "") ? substitute_var( rm_comment( _conf{ key } ) ) : curr_val
		}
	}
	return curr_val
}

string substitute_var( string var ) {

	var1 := var.replace("\$script_dir","$script_dir").replace("\${script_dir}","$script_dir")
	var2 := var1.replace("\$dir_sw","$dir_sw").replace("\${dir_sw}","$dir_sw")
	var3 := var2.replace("~/","$HOME/")
	var4 := var3.replace("\$HOME","$HOME").replace("\${HOME}","$HOME")

	return var4
}

string get_conf_val( string curr_val, string[] keys, string{} _conf ) {		

	for ( string key : keys ) {
		val := get_conf_val( curr_val, key, _conf )		
		if ( val != curr_val ) return val
	} 
	return curr_val
}

string get_conf_val( string curr_val, string key ) {

	string{} tmp
	return get_conf_val( curr_val, key, tmp )
}

string get_conf_val( string curr_val, string[] keys ) {	

	string{} tmp
	return get_conf_val( curr_val, keys, tmp )
}

bool has_conf_key( string key, string{} _conf ) {

	key = key.toLower()
	return (_conf.size()==0) ? conf.hasKey( key ) : _conf.hasKey( key )
}

bool has_conf_key( string key ) {

	string{} tmp
	return has_conf_key( key )
}

bool conf_file_exists() {
	if ( c!="" ) return c.exists()
	return false
}
