#!/usr/bin/env bds
#vim: syntax=java

include "species.bds"
include "report.bds"


help == IDR settings
idr_suffix 	:= false 	help Append IDR threshold to IDR output directory.


init_idr()

void init_idr() {

	idr_suffix 	= get_conf_val_bool( idr_suffix, 	["idr_suffix"] )

	print_idr()
}

void print_idr() {

	print( "\n\n== IDR settings\n")
	print( "Append IDR threshold to IDR out_dir\t\t: $idr_suffix\n" )
}

void chk_idr() {
	if ( !path_exists( blacklist_idr ) ) print("\nWarning: Blacklist bed (-blacklist_idr) for final IDR QC is missing! (file: $blacklist_idr)\n\n")
}


// 13-col.bed.gz (10 col for narrowPeak + local IDR, global IDR, 0 ) will be generated for browser tracks
// there is a 13th column due to bedtools intersect compatibility issue
// use function _get_idr_peak_trk( idr_peak ) to find 13-col.bed.gz for browser tracks
// rank: 'signal.value' for SPP peaks, 'p.value' for MACS2 peaks
string[] _idr2( string peak1, string peak2, string pooled, string idr_thresh, string rank, string o_dir, string label, \
		string graph_prefix, string[] graph_in, string hrchy ) {

	if ( idr_suffix ) o_dir = mkdir( o_dir + "_$idr_thresh" )

	prefix 		:= "$o_dir/" + (title=="" ? "" : (title+"_") ) + label	
	peak_idr	:= "$prefix.IDR"+"$idr_thresh.narrowPeak.gz"
	peak_idr_trk	:= "$prefix.IDR"+"$idr_thresh.13-col.bed.gz"
	idr_out 	:= "$prefix.unthresholded-peaks.txt"
	idr_out_gz	:= "$idr_out.gz"
	png 		:= "$idr_out.png"

	in 	:= [peak1, peak2, pooled]
	out 	:= [peak_idr, png, idr_out_gz,peak_idr_trk]

	taskName:= "idr2 " + label

	task( out<-in ) {
		
		sys $shcmd_init_py3

		sys idr --samples $peak1 $peak2 --peak-list $pooled --input-file-type narrowPeak \
			--output-file $idr_out --rank $rank --soft-idr-threshold $idr_thresh \
			--plot
		
		sys idr_thresh_transformed=$(awk -v p=$idr_thresh 'BEGIN{print -log(p)/log(10)}')

		//# Get peaks passing global IDR threshold and convert file to narrowPeak format (Step 9)
		sys awk 'BEGIN{OFS="\t"} $12>='"${idr_thresh_transformed}"' {print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' $idr_out \
			| sort | uniq | sort -k7n,7n | gzip -c > $peak_idr

		sys awk 'BEGIN{OFS="\t"} $12>='"${idr_thresh_transformed}"' {print $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,"0"}' $idr_out \
			| sort | uniq | sort -k7n,7n | gzip -c > $peak_idr_trk

		sys gzip -f $idr_out
	}

	for ( int i=0; i<graph_in.size(); i++) graph_in[i] = graph_prefix + "_(" + graph_in[i] + ")"

	graph_out := ["idr_peak_($label)"]
	hrchy_out := ["L1_peak/idr/$hrchy/idr_peak","","L1_peak/idr/$hrchy/unthsld_peak"]

	_add_to_graphviz( graph_in, in, graph_out, out, "idr_($label)", grp_color_idr )
	_add_to_filetable( hrchy_out, out )

	wait_par()

	return out
}

// idr_tr: IDR peaks for true replicate (key:"rep_id1,rep_id2") e.g. "1,2" for rep1 and rep2
// idr_pr: IDR peaks for pseudo replicates (key:"rep") e.g. "1" for pseudo replicates of replicate 1
string[] _idr_final_qc( string{} idr_tr, string{} idr_pr, string idr_ppr, \
			string idr_o_dir, string qc_o_dir, string label ) {

	string{} idr_tr_filt
	string idr_ppr_filt
	string remarks
	
	// filter IDR peaks with blacklist

	if ( path_exists( blacklist_idr ) ) { 

		for ( string key : idr_tr.keys() ) { // key = rep id 1, rep id 2
			idr_tr_filt{key} = _filter_idr_peak( idr_tr{key}, "", key )
		}
		
		idr_ppr_filt 	= _filter_idr_peak( idr_ppr, "", "ppr" )
		wait

		remarks		= "filtered tr and ppr"
	}
	else {
		idr_tr_filt 	= idr_tr
		idr_ppr_filt 	= idr_ppr

		remarks		= "no blacklist"
	}


	// get # of lines in each IRD peak files
	int Nt
	string idr_tr_filt_best
	string key_tr_best

	for ( string key : idr_tr_filt.keys() ) { // key = rep id 1, rep id 2

		peak := idr_tr_filt{ key }
		nlines := get_no_lines( peak )

		if ( nlines >= Nt ) {
			Nt = nlines
			idr_tr_filt_best = peak
			key_tr_best = key
		}
	}

	int[] N
	for ( string peak : idr_pr ) N.add( get_no_lines( peak ) )

	Np :=  get_no_lines( idr_ppr_filt )

	// find optimal set and conservative set

	// optimal set
	optimal_set 		:= (Nt > Np) ? _get_label_from_key(key_tr_best) : "pooled_pseudo_rep"
	idr_opt_set 		:= (Nt > Np) ? idr_tr_filt_best : idr_ppr_filt

	// conservative set
	conservative_set 	:= _get_label_from_key(key_tr_best)
	idr_consv_set  	 	:= idr_tr_filt_best

	// make a copy of them

	idr_opt_o_dir 		:= mkdir( "$idr_o_dir/optimal_set" )
	idr_consv_o_dir 	:= mkdir( "$idr_o_dir/conservative_set" )

	idr_opt_set_new		:= copy( idr_opt_set, idr_opt_o_dir )	
	idr_consv_set_new 	:= copy( idr_consv_set, idr_consv_o_dir )
	
	// for browser tracks
	idr_opt_set_trk 	:= _get_idr_peak_trk( idr_opt_set ) // for browser tracks
	idr_consv_set_trk	:= _get_idr_peak_trk( idr_consv_set ) // for browser tracks

	copy( idr_opt_set_trk, idr_opt_o_dir )
	copy( idr_consv_set_trk, idr_consv_o_dir )

	wait

	// compute IDR scores

	real max_Np_Nt = max( Np, Nt )
	real min_Np_Nt = min( Np, Nt )

	max_N_int := max( N )
	min_N_int := min( N )
	real max_N = max_N_int
	real min_N = min_N_int

	rescue_ratio 		:= max_Np_Nt / min_Np_Nt
	self_consistency_ratio 	:= max_N / min_N
	reproducibility 	:= 1

	if ( rescue_ratio > 2.0 || self_consistency_ratio > 2.0 ) reproducibility = 0 // BORDERLINE
	if ( rescue_ratio > 2.0 && self_consistency_ratio > 2.0 ) reproducibility = -1 // FAIL
	
	// 4f. Fraction of Reads in Peaks (FRiP) will be added later

	// write on IDR FINAL QC file
	prefix 	:= "$qc_o_dir/" + (title=="" ? "" : (title+"_") ) + label
	qc 	:= prefix+"IDR_final.qc"

	in 	:= map_to_array( idr_tr ) + map_to_array( idr_pr ) + [idr_ppr]
	out 	:= qc

	taskName:= "idr final qc" + label

	task( out<-in ) {

		sys $shcmd_init

		sys echo -e "Nt\tN_min\tN_max\tNp\tconservative_set\toptimal_set\trescue_ratio\tself_consistency_ratio\treproducibility\tremarks" > $qc
		sys echo -e "$Nt\t$min_N_int\t$max_N_int\t$Np\t$conservative_set\t$optimal_set\t$rescue_ratio\t$self_consistency_ratio\t$reproducibility\t$remarks" >> $qc
	}

	wait_par()

	string[] graph_in

	for ( string key : idr_tr.keys() ) graph_in.add( "idr_peak_("+_get_label_from_key(key)+")" )	
	for ( string key : idr_pr.keys() ) graph_in.add( "idr_peak_(rep$key-pr)" )	

	graph_in  += ["idr_peak_(ppr)"]
	graph_out := ["idr_qc","idr_peak_(opt)","idr_peak_(consv)"]

	hrchy_out := ["L1_qc/idr_qc","L1_peak/idr/opt_set/idr_peak","L1_peak/idr/consv_set/idr_peak"]

	_add_to_graphviz( graph_in, in, graph_out, [qc, idr_opt_set_new, idr_consv_set_new], "idr\\nfinal\\nqc", grp_color_idr_final )
	_add_to_filetable( hrchy_out, [qc, idr_opt_set_new, idr_consv_set_new] )

	return [qc, idr_opt_set_new, idr_consv_set_new]
}

string _get_label_from_key( string key ) { //parse "i,j" to "repi-repj"
	tmp := key.split(",")
	i := tmp[0]
	j := tmp[1]
	return "rep$i-rep$j"
}

string _get_idr_peak_trk( string idr_peak ) {

	return rm_ext( idr_peak, ["narrowPeak","regionPeak"] ) + ".13-col.bed.gz"	
}

string _filter_idr_peak( string idr_peak, string o_dir, string label ) {

	// check if IDR peak for track exists
	idr_peak_trk	:= _get_idr_peak_trk( idr_peak )

	prefix 		:= replace_dir( rm_ext( idr_peak, ["narrowPeak","regionPeak"] ), o_dir )
	filt 		:= "$prefix.filt.narrowPeak.gz"
	filt_trk	:= "$prefix.filt.13-col.bed.gz"

	in 	:= [idr_peak]
	out 	:= filt

	taskName:= "filter_idr_peak " + label

	task( out<-in ) {

		sys $shcmd_init

		sys bedtools intersect -v -a $idr_peak -b $blacklist_idr | gzip -c > $filt

		// filter 13-col bed too for browser tracks
		sys if [ -f $idr_peak_trk ]; then bedtools intersect -v -a $idr_peak_trk -b $blacklist_idr | gzip -c > $filt_trk; fi
	}

	wait_par()

	return out
}
